<?php
/**
 * DefaultApi
 * PHP version 7.2
 *
 * @category Class
 * @package  Here
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */

/**
 * Geocoding and Search API v1
 *
 * This document describes the Geocoding and Search API.
 *
 * The version of the OpenAPI document: 1.59
 * 
 * Generated by: https://openapi-generator.tech
 * OpenAPI Generator version: 5.0.1
 */

/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

namespace Here\Api;

use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\RequestOptions;
use Here\ApiException;
use Here\Configuration;
use Here\HeaderSelector;
use Here\ObjectSerializer;

/**
 * DefaultApi Class Doc Comment
 *
 * @category Class
 * @package  Here
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */
class DefaultApi
{
    /**
     * @var ClientInterface
     */
    protected $client;

    /**
     * @var Configuration
     */
    protected $config;

    /**
     * @var HeaderSelector
     */
    protected $headerSelector;

    /**
     * @var int Host index
     */
    protected $hostIndex;

    /**
     * @param ClientInterface $client
     * @param Configuration   $config
     * @param HeaderSelector  $selector
     * @param int             $hostIndex (Optional) host index to select the list of hosts if defined in the OpenAPI spec
     */
    public function __construct(
        ClientInterface $client = null,
        Configuration $config = null,
        HeaderSelector $selector = null,
        $hostIndex = 0
    ) {
        $this->client = $client ?: new Client();
        $this->config = $config ?: new Configuration();
        $this->headerSelector = $selector ?: new HeaderSelector();
        $this->hostIndex = $hostIndex;
    }

    /**
     * Set the host index
     *
     * @param int $hostIndex Host index (required)
     */
    public function setHostIndex($hostIndex)
    {
        $this->hostIndex = $hostIndex;
    }

    /**
     * Get the host index
     *
     * @return int Host index
     */
    public function getHostIndex()
    {
        return $this->hostIndex;
    }

    /**
     * @return Configuration
     */
    public function getConfig()
    {
        return $this->config;
    }

    /**
     * Operation autocompleteGet
     *
     * Autocomplete
     *
     * This oepration contains host(s) defined in the OpenAP spec. Use 'hostIndex' to select the host.
     * URL: https://autocomplete.search.hereapi.com/v1
     *
     * @param  string $q Enter a free-text query  Examples:  * &#x60;ber&#x60;, &#x60;berl&#x60;, &#x60;berli&#x60;, ...  * &#x60;berlin+p&#x60;, &#x60;berlin+paris&#x60;, &#x60;berlin+parise&#x60;, ...  * &#x60;berlin+pariser+20&#x60;   _Note: Whitespace, urls, email addresses, or other out-of-scope queries will yield no results._ (required)
     * @param  string $at Specify the center of the search context expressed as coordinates.  Format: &#x60;{latitude},{longitude}&#x60;  Type: &#x60;{decimal},{decimal}&#x60;  Example: &#x60;-13.163068,-72.545128&#x60; (Machu Picchu Mountain, Peru) (optional)
     * @param  string $in Search within a geographic area. This is a hard filter. Results will be returned if they are located within the specified area.  A geographic area can be   * a country (or multiple countries), provided as comma-separated [ISO 3166-1 alpha-3](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-3) country codes     The country codes are to be provided in all uppercase.     Format: &#x60;countryCode:{countryCode}[,{countryCode}]*&#x60;     Examples:     * &#x60;countryCode:USA&#x60;     * &#x60;countryCode:CAN,MEX,USA&#x60; (optional)
     * @param  int $limit Maximum number of results to be returned. (optional, default to 5)
     * @param  string[] $types BETA: Limit the result items to the specified types. Currently supported values of the type filter for Autocomplete:       | * &#x60;city&#x60; - restricting results to result type &#x60;locality&#x60; and locality type &#x60;city&#x60;       | * &#x60;postalCode&#x60; - restricting results to result type &#x60;locality&#x60; and locality type &#x60;postalCode&#x60;,       | * &#x60;area&#x60; - restricting results to result types: &#x60;locality&#x60; or &#x60;administrativeArea&#x60; including all the sub-types       |       |Provide one of the supported values or a comma separated list.       |       | (optional)
     * @param  string $lang Select the preferred response language for result rendering from a list of BCP47 compliant Language Codes. The autocomplete endpoint tries to detect the query language based on matching name variants and then chooses the same language for the response.  Therefore the end-user can see and recognize all the entered terms in the same language as in the query. The specified preferred language is used only for not matched address tokens and for matched address tokens in case of ambiguity (optional)
     * @param  string $x_request_id Used to correlate requests with their responses within a customer&#39;s application, for logging and error reporting.  Format: Free string, but a valid UUIDv4 is recommended. (optional)
     *
     * @throws \Here\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Here\Model\OpenSearchAutocompleteResponse|\Here\Model\ErrorResponse|\Here\Model\ErrorResponse|\Here\Model\ErrorResponse
     */
    public function autocompleteGet($q, $at = null, $in = null, $limit = 5, $types = null, $lang = null, $x_request_id = null)
    {
        list($response) = $this->autocompleteGetWithHttpInfo($q, $at, $in, $limit, $types, $lang, $x_request_id);
        return $response;
    }

    /**
     * Operation autocompleteGetWithHttpInfo
     *
     * Autocomplete
     *
     * This oepration contains host(s) defined in the OpenAP spec. Use 'hostIndex' to select the host.
     * URL: https://autocomplete.search.hereapi.com/v1
     *
     * @param  string $q Enter a free-text query  Examples:  * &#x60;ber&#x60;, &#x60;berl&#x60;, &#x60;berli&#x60;, ...  * &#x60;berlin+p&#x60;, &#x60;berlin+paris&#x60;, &#x60;berlin+parise&#x60;, ...  * &#x60;berlin+pariser+20&#x60;   _Note: Whitespace, urls, email addresses, or other out-of-scope queries will yield no results._ (required)
     * @param  string $at Specify the center of the search context expressed as coordinates.  Format: &#x60;{latitude},{longitude}&#x60;  Type: &#x60;{decimal},{decimal}&#x60;  Example: &#x60;-13.163068,-72.545128&#x60; (Machu Picchu Mountain, Peru) (optional)
     * @param  string $in Search within a geographic area. This is a hard filter. Results will be returned if they are located within the specified area.  A geographic area can be   * a country (or multiple countries), provided as comma-separated [ISO 3166-1 alpha-3](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-3) country codes     The country codes are to be provided in all uppercase.     Format: &#x60;countryCode:{countryCode}[,{countryCode}]*&#x60;     Examples:     * &#x60;countryCode:USA&#x60;     * &#x60;countryCode:CAN,MEX,USA&#x60; (optional)
     * @param  int $limit Maximum number of results to be returned. (optional, default to 5)
     * @param  string[] $types BETA: Limit the result items to the specified types. Currently supported values of the type filter for Autocomplete:       | * &#x60;city&#x60; - restricting results to result type &#x60;locality&#x60; and locality type &#x60;city&#x60;       | * &#x60;postalCode&#x60; - restricting results to result type &#x60;locality&#x60; and locality type &#x60;postalCode&#x60;,       | * &#x60;area&#x60; - restricting results to result types: &#x60;locality&#x60; or &#x60;administrativeArea&#x60; including all the sub-types       |       |Provide one of the supported values or a comma separated list.       |       | (optional)
     * @param  string $lang Select the preferred response language for result rendering from a list of BCP47 compliant Language Codes. The autocomplete endpoint tries to detect the query language based on matching name variants and then chooses the same language for the response.  Therefore the end-user can see and recognize all the entered terms in the same language as in the query. The specified preferred language is used only for not matched address tokens and for matched address tokens in case of ambiguity (optional)
     * @param  string $x_request_id Used to correlate requests with their responses within a customer&#39;s application, for logging and error reporting.  Format: Free string, but a valid UUIDv4 is recommended. (optional)
     *
     * @throws \Here\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Here\Model\OpenSearchAutocompleteResponse|\Here\Model\ErrorResponse|\Here\Model\ErrorResponse|\Here\Model\ErrorResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function autocompleteGetWithHttpInfo($q, $at = null, $in = null, $limit = 5, $types = null, $lang = null, $x_request_id = null)
    {
        $request = $this->autocompleteGetRequest($q, $at, $in, $limit, $types, $lang, $x_request_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\Here\Model\OpenSearchAutocompleteResponse' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Here\Model\OpenSearchAutocompleteResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    if ('\Here\Model\ErrorResponse' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Here\Model\ErrorResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 405:
                    if ('\Here\Model\ErrorResponse' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Here\Model\ErrorResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 503:
                    if ('\Here\Model\ErrorResponse' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Here\Model\ErrorResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Here\Model\OpenSearchAutocompleteResponse';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Here\Model\OpenSearchAutocompleteResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Here\Model\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 405:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Here\Model\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 503:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Here\Model\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation autocompleteGetAsync
     *
     * Autocomplete
     *
     * This oepration contains host(s) defined in the OpenAP spec. Use 'hostIndex' to select the host.
     * URL: https://autocomplete.search.hereapi.com/v1
     *
     * @param  string $q Enter a free-text query  Examples:  * &#x60;ber&#x60;, &#x60;berl&#x60;, &#x60;berli&#x60;, ...  * &#x60;berlin+p&#x60;, &#x60;berlin+paris&#x60;, &#x60;berlin+parise&#x60;, ...  * &#x60;berlin+pariser+20&#x60;   _Note: Whitespace, urls, email addresses, or other out-of-scope queries will yield no results._ (required)
     * @param  string $at Specify the center of the search context expressed as coordinates.  Format: &#x60;{latitude},{longitude}&#x60;  Type: &#x60;{decimal},{decimal}&#x60;  Example: &#x60;-13.163068,-72.545128&#x60; (Machu Picchu Mountain, Peru) (optional)
     * @param  string $in Search within a geographic area. This is a hard filter. Results will be returned if they are located within the specified area.  A geographic area can be   * a country (or multiple countries), provided as comma-separated [ISO 3166-1 alpha-3](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-3) country codes     The country codes are to be provided in all uppercase.     Format: &#x60;countryCode:{countryCode}[,{countryCode}]*&#x60;     Examples:     * &#x60;countryCode:USA&#x60;     * &#x60;countryCode:CAN,MEX,USA&#x60; (optional)
     * @param  int $limit Maximum number of results to be returned. (optional, default to 5)
     * @param  string[] $types BETA: Limit the result items to the specified types. Currently supported values of the type filter for Autocomplete:       | * &#x60;city&#x60; - restricting results to result type &#x60;locality&#x60; and locality type &#x60;city&#x60;       | * &#x60;postalCode&#x60; - restricting results to result type &#x60;locality&#x60; and locality type &#x60;postalCode&#x60;,       | * &#x60;area&#x60; - restricting results to result types: &#x60;locality&#x60; or &#x60;administrativeArea&#x60; including all the sub-types       |       |Provide one of the supported values or a comma separated list.       |       | (optional)
     * @param  string $lang Select the preferred response language for result rendering from a list of BCP47 compliant Language Codes. The autocomplete endpoint tries to detect the query language based on matching name variants and then chooses the same language for the response.  Therefore the end-user can see and recognize all the entered terms in the same language as in the query. The specified preferred language is used only for not matched address tokens and for matched address tokens in case of ambiguity (optional)
     * @param  string $x_request_id Used to correlate requests with their responses within a customer&#39;s application, for logging and error reporting.  Format: Free string, but a valid UUIDv4 is recommended. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function autocompleteGetAsync($q, $at = null, $in = null, $limit = 5, $types = null, $lang = null, $x_request_id = null)
    {
        return $this->autocompleteGetAsyncWithHttpInfo($q, $at, $in, $limit, $types, $lang, $x_request_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation autocompleteGetAsyncWithHttpInfo
     *
     * Autocomplete
     *
     * This oepration contains host(s) defined in the OpenAP spec. Use 'hostIndex' to select the host.
     * URL: https://autocomplete.search.hereapi.com/v1
     *
     * @param  string $q Enter a free-text query  Examples:  * &#x60;ber&#x60;, &#x60;berl&#x60;, &#x60;berli&#x60;, ...  * &#x60;berlin+p&#x60;, &#x60;berlin+paris&#x60;, &#x60;berlin+parise&#x60;, ...  * &#x60;berlin+pariser+20&#x60;   _Note: Whitespace, urls, email addresses, or other out-of-scope queries will yield no results._ (required)
     * @param  string $at Specify the center of the search context expressed as coordinates.  Format: &#x60;{latitude},{longitude}&#x60;  Type: &#x60;{decimal},{decimal}&#x60;  Example: &#x60;-13.163068,-72.545128&#x60; (Machu Picchu Mountain, Peru) (optional)
     * @param  string $in Search within a geographic area. This is a hard filter. Results will be returned if they are located within the specified area.  A geographic area can be   * a country (or multiple countries), provided as comma-separated [ISO 3166-1 alpha-3](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-3) country codes     The country codes are to be provided in all uppercase.     Format: &#x60;countryCode:{countryCode}[,{countryCode}]*&#x60;     Examples:     * &#x60;countryCode:USA&#x60;     * &#x60;countryCode:CAN,MEX,USA&#x60; (optional)
     * @param  int $limit Maximum number of results to be returned. (optional, default to 5)
     * @param  string[] $types BETA: Limit the result items to the specified types. Currently supported values of the type filter for Autocomplete:       | * &#x60;city&#x60; - restricting results to result type &#x60;locality&#x60; and locality type &#x60;city&#x60;       | * &#x60;postalCode&#x60; - restricting results to result type &#x60;locality&#x60; and locality type &#x60;postalCode&#x60;,       | * &#x60;area&#x60; - restricting results to result types: &#x60;locality&#x60; or &#x60;administrativeArea&#x60; including all the sub-types       |       |Provide one of the supported values or a comma separated list.       |       | (optional)
     * @param  string $lang Select the preferred response language for result rendering from a list of BCP47 compliant Language Codes. The autocomplete endpoint tries to detect the query language based on matching name variants and then chooses the same language for the response.  Therefore the end-user can see and recognize all the entered terms in the same language as in the query. The specified preferred language is used only for not matched address tokens and for matched address tokens in case of ambiguity (optional)
     * @param  string $x_request_id Used to correlate requests with their responses within a customer&#39;s application, for logging and error reporting.  Format: Free string, but a valid UUIDv4 is recommended. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function autocompleteGetAsyncWithHttpInfo($q, $at = null, $in = null, $limit = 5, $types = null, $lang = null, $x_request_id = null)
    {
        $returnType = '\Here\Model\OpenSearchAutocompleteResponse';
        $request = $this->autocompleteGetRequest($q, $at, $in, $limit, $types, $lang, $x_request_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'autocompleteGet'
     *
     * This oepration contains host(s) defined in the OpenAP spec. Use 'hostIndex' to select the host.
     * URL: https://autocomplete.search.hereapi.com/v1
     *
     * @param  string $q Enter a free-text query  Examples:  * &#x60;ber&#x60;, &#x60;berl&#x60;, &#x60;berli&#x60;, ...  * &#x60;berlin+p&#x60;, &#x60;berlin+paris&#x60;, &#x60;berlin+parise&#x60;, ...  * &#x60;berlin+pariser+20&#x60;   _Note: Whitespace, urls, email addresses, or other out-of-scope queries will yield no results._ (required)
     * @param  string $at Specify the center of the search context expressed as coordinates.  Format: &#x60;{latitude},{longitude}&#x60;  Type: &#x60;{decimal},{decimal}&#x60;  Example: &#x60;-13.163068,-72.545128&#x60; (Machu Picchu Mountain, Peru) (optional)
     * @param  string $in Search within a geographic area. This is a hard filter. Results will be returned if they are located within the specified area.  A geographic area can be   * a country (or multiple countries), provided as comma-separated [ISO 3166-1 alpha-3](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-3) country codes     The country codes are to be provided in all uppercase.     Format: &#x60;countryCode:{countryCode}[,{countryCode}]*&#x60;     Examples:     * &#x60;countryCode:USA&#x60;     * &#x60;countryCode:CAN,MEX,USA&#x60; (optional)
     * @param  int $limit Maximum number of results to be returned. (optional, default to 5)
     * @param  string[] $types BETA: Limit the result items to the specified types. Currently supported values of the type filter for Autocomplete:       | * &#x60;city&#x60; - restricting results to result type &#x60;locality&#x60; and locality type &#x60;city&#x60;       | * &#x60;postalCode&#x60; - restricting results to result type &#x60;locality&#x60; and locality type &#x60;postalCode&#x60;,       | * &#x60;area&#x60; - restricting results to result types: &#x60;locality&#x60; or &#x60;administrativeArea&#x60; including all the sub-types       |       |Provide one of the supported values or a comma separated list.       |       | (optional)
     * @param  string $lang Select the preferred response language for result rendering from a list of BCP47 compliant Language Codes. The autocomplete endpoint tries to detect the query language based on matching name variants and then chooses the same language for the response.  Therefore the end-user can see and recognize all the entered terms in the same language as in the query. The specified preferred language is used only for not matched address tokens and for matched address tokens in case of ambiguity (optional)
     * @param  string $x_request_id Used to correlate requests with their responses within a customer&#39;s application, for logging and error reporting.  Format: Free string, but a valid UUIDv4 is recommended. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function autocompleteGetRequest($q, $at = null, $in = null, $limit = 5, $types = null, $lang = null, $x_request_id = null)
    {
        // verify the required parameter 'q' is set
        if ($q === null || (is_array($q) && count($q) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $q when calling autocompleteGet'
            );
        }
        if ($limit !== null && $limit > 20) {
            throw new \InvalidArgumentException('invalid value for "$limit" when calling DefaultApi.autocompleteGet, must be smaller than or equal to 20.');
        }
        if ($limit !== null && $limit < 1) {
            throw new \InvalidArgumentException('invalid value for "$limit" when calling DefaultApi.autocompleteGet, must be bigger than or equal to 1.');
        }


        $resourcePath = '/autocomplete';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($q !== null) {
            if('form' === 'form' && is_array($q)) {
                foreach($q as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['q'] = $q;
            }
        }
        // query params
        if ($at !== null) {
            if('form' === 'form' && is_array($at)) {
                foreach($at as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['at'] = $at;
            }
        }
        // query params
        if ($in !== null) {
            if('form' === 'form' && is_array($in)) {
                foreach($in as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['in'] = $in;
            }
        }
        // query params
        if ($limit !== null) {
            if('form' === 'form' && is_array($limit)) {
                foreach($limit as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['limit'] = $limit;
            }
        }
        // query params
        if (is_array($types)) {
            $types = ObjectSerializer::serializeCollection($types, 'form', true);
        }
        if ($types !== null) {
            $queryParams['types'] = $types;
        }
        // query params
        if ($lang !== null) {
            if('form' === 'form' && is_array($lang)) {
                foreach($lang as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['lang'] = $lang;
            }
        }

        // header params
        if ($x_request_id !== null) {
            $headerParams['X-Request-ID'] = ObjectSerializer::toHeaderValue($x_request_id);
        }



        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('apiKey');
        if ($apiKey !== null) {
            $queryParams['apiKey'] = $apiKey;
        }
        // this endpoint requires Bearer (JWT) authentication (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHosts = ["https://autocomplete.search.hereapi.com/v1"];
        if ($this->hostIndex < 0 || $this->hostIndex >= sizeof($operationHosts)) {
            throw new \InvalidArgumentException("Invalid index {$this->hostIndex} when selecting the host. Must be less than ".sizeof($operationHosts));
        }
        $operationHost = $operationHosts[$this->hostIndex];

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation autosuggestGet
     *
     * Autosuggest
     *
     * This oepration contains host(s) defined in the OpenAP spec. Use 'hostIndex' to select the host.
     * URL: https://autosuggest.search.hereapi.com/v1
     *
     * @param  string $q Enter a free-text query  Examples:  * &#x60;res&#x60;, &#x60;rest&#x60;, &#x60;resta&#x60;, &#x60;restau&#x60;, ...  * &#x60;berlin+bran&#x60;, &#x60;berlin+brand&#x60;, &#x60;berlin+branden&#x60;, ...  * &#x60;New+Yok+Giants&#x60;   _Note: Whitespace, urls, email addresses, or other out-of-scope queries will yield no results. (required)
     * @param  string $at Specify the center of the search context expressed as coordinates  Format: &#x60;{latitude},{longitude}&#x60;  Type: &#x60;{decimal},{decimal}&#x60;  Example: &#x60;-13.163068,-72.545128&#x60; (Machu Picchu Mountain, Peru)  The following constraints apply:   * One of \&quot;at\&quot;, \&quot;in&#x3D;circle\&quot; or \&quot;in&#x3D;bbox\&quot; is required.   * Parameters \&quot;at\&quot;, \&quot;in&#x3D;circle\&quot; and \&quot;in&#x3D;bbox\&quot; are mutually exclusive. Only one of them is allowed. (optional)
     * @param  string $in Search within a geographic area. This is a hard filter. Results will be returned if they are located within the specified area.  A geographic area can be   * a country (or multiple countries), provided as comma-separated [ISO 3166-1 alpha-3](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-3) country codes     The country codes are to be provided in all uppercase.     Format: &#x60;countryCode:{countryCode}[,{countryCode}]*&#x60;     Examples:     * &#x60;countryCode:USA&#x60;     * &#x60;countryCode:CAN,MEX,USA&#x60;    * a circular area, provided as latitude, longitude, and radius (in meters)     Format: &#x60;circle:{latitude},{longitude};r&#x3D;{radius}&#x60;     Type: &#x60;circle:{decimal},{decimal};r&#x3D;{integer}&#x60;     Example: &#x60;circle:52.53,13.38;r&#x3D;10000&#x60;    * a bounding box, provided as _west longitude_, _south latitude_, _east longitude_, _north latitude_     Format: &#x60;bbox:{west longitude},{south latitude},{east longitude},{north latitude}&#x60;     Example: &#x60;bbox:13.08836,52.33812,13.761,52.6755&#x60;   The following constraints apply:   * Parameters \&quot;at\&quot;, \&quot;in&#x3D;circle\&quot; and \&quot;in&#x3D;bbox\&quot; are mutually exclusive. Only one of them is allowed.    * One of \&quot;at\&quot;, \&quot;in&#x3D;circle\&quot; or \&quot;in&#x3D;bbox\&quot; is required.   * The \&quot;in&#x3D;countryCode\&quot; parameter must be accompanied by exactly one of \&quot;at\&quot;, \&quot;in&#x3D;circle\&quot; or \&quot;in&#x3D;bbox\&quot;. (optional)
     * @param  int $limit Maximum number of results to be returned. (optional, default to 20)
     * @param  string $route BETA: Select within a geographic corridor. This is a hard filter. Results will be returned if they are located within the specified area.  A &#x60;route&#x60; is defined by a [Flexible Polyline Encoding](https://github.com/heremaps/flexible-polyline),  followed by an optional width, represented by a sub-parameter \&quot;w\&quot;.   Format: &#x60;{route};w&#x3D;{width}&#x60;  In regular expression syntax, the values of &#x60;route&#x60; look like:  &#x60;[a-zA-Z0-9_-]+(;w&#x3D;\\d+)?&#x60;  \&quot;[a-zA-Z0-9._-]+\&quot; is the encoded flexible polyline.  \&quot;w&#x3D;\\d+\&quot; is the optional width. The width is specified in meters from the center of the path. If no width is provided, the default is 1000 meters.  Type: &#x60;{Flexible Polyline Encoding};w&#x3D;{integer}&#x60;  Examples:  * &#x60;BFoz5xJ67i1B1B7PzIhaxL7Y&#x60;  * &#x60;BFoz5xJ67i1B1B7PzIhaxL7Y;w&#x3D;5000&#x60;  * &#x60;BlD05xgKuy2xCCx9B7vUCl0OhnRC54EqSCzpEl-HCxjD3pBCiGnyGCi2CvwFCsgD3nDC4vB6eC;w&#x3D;2000&#x60;  Note: The last example above can be decoded (using the Python class [here](https://github.com/heremaps/flexible-polyline/tree/master/python) as follows:  &#x60;&#x60;&#x60; &gt;&gt;&gt; import flexpolyline &gt;&gt;&gt; polyline &#x3D; &#39;BlD05xgKuy2xCCx9B7vUCl0OhnRC54EqSCzpEl-HCxjD3pBCiGnyGCi2CvwFCsgD3nDC4vB6eC&#39; &gt;&gt;&gt; flexpolyline.decode(polyline) [(52.51994, 13.38663, 1.0), (52.51009, 13.28169, 2.0), (52.43518, 13.19352, 3.0), (52.41073, 13.19645, 4.0), (52.38871, 13.15578, 5.0), (52.37278, 13.1491, 6.0), (52.37375, 13.11546, 7.0), (52.38752, 13.08722, 8.0), (52.40294, 13.07062, 9.0), (52.41058, 13.07555, 10.0)] &#x60;&#x60;&#x60; (optional)
     * @param  int $terms_limit BETA: Maximum number of Query Terms Suggestions to be returned. (optional)
     * @param  string $lang Select the language to be used for result rendering from a list of [BCP 47](https://en.wikipedia.org/wiki/IETF_language_tag) compliant language codes. (optional)
     * @param  string[] $show Select additional fields to be rendered in the response. Please note that some of the fields involve additional webservice calls and can increase the overall response time.  The value is a comma-separated list of the sections to be enabled. For each section there is a long and a short version of its id.  Description of accepted values:  &#39;details&#39;: Renders address and contact details, as well as opening hours of the searched place.  &#39;phonemes&#39;: Renders phonemes for address and place names into the results. (optional)
     * @param  string $x_request_id Used to correlate requests with their responses within a customer&#39;s application, for logging and error reporting.  Format: Free string, but a valid UUIDv4 is recommended. (optional)
     *
     * @throws \Here\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Here\Model\OpenSearchAutosuggestResponse|\Here\Model\ErrorResponse|\Here\Model\ErrorResponse|\Here\Model\ErrorResponse
     */
    public function autosuggestGet($q, $at = null, $in = null, $limit = 20, $route = null, $terms_limit = null, $lang = null, $show = null, $x_request_id = null)
    {
        list($response) = $this->autosuggestGetWithHttpInfo($q, $at, $in, $limit, $route, $terms_limit, $lang, $show, $x_request_id);
        return $response;
    }

    /**
     * Operation autosuggestGetWithHttpInfo
     *
     * Autosuggest
     *
     * This oepration contains host(s) defined in the OpenAP spec. Use 'hostIndex' to select the host.
     * URL: https://autosuggest.search.hereapi.com/v1
     *
     * @param  string $q Enter a free-text query  Examples:  * &#x60;res&#x60;, &#x60;rest&#x60;, &#x60;resta&#x60;, &#x60;restau&#x60;, ...  * &#x60;berlin+bran&#x60;, &#x60;berlin+brand&#x60;, &#x60;berlin+branden&#x60;, ...  * &#x60;New+Yok+Giants&#x60;   _Note: Whitespace, urls, email addresses, or other out-of-scope queries will yield no results. (required)
     * @param  string $at Specify the center of the search context expressed as coordinates  Format: &#x60;{latitude},{longitude}&#x60;  Type: &#x60;{decimal},{decimal}&#x60;  Example: &#x60;-13.163068,-72.545128&#x60; (Machu Picchu Mountain, Peru)  The following constraints apply:   * One of \&quot;at\&quot;, \&quot;in&#x3D;circle\&quot; or \&quot;in&#x3D;bbox\&quot; is required.   * Parameters \&quot;at\&quot;, \&quot;in&#x3D;circle\&quot; and \&quot;in&#x3D;bbox\&quot; are mutually exclusive. Only one of them is allowed. (optional)
     * @param  string $in Search within a geographic area. This is a hard filter. Results will be returned if they are located within the specified area.  A geographic area can be   * a country (or multiple countries), provided as comma-separated [ISO 3166-1 alpha-3](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-3) country codes     The country codes are to be provided in all uppercase.     Format: &#x60;countryCode:{countryCode}[,{countryCode}]*&#x60;     Examples:     * &#x60;countryCode:USA&#x60;     * &#x60;countryCode:CAN,MEX,USA&#x60;    * a circular area, provided as latitude, longitude, and radius (in meters)     Format: &#x60;circle:{latitude},{longitude};r&#x3D;{radius}&#x60;     Type: &#x60;circle:{decimal},{decimal};r&#x3D;{integer}&#x60;     Example: &#x60;circle:52.53,13.38;r&#x3D;10000&#x60;    * a bounding box, provided as _west longitude_, _south latitude_, _east longitude_, _north latitude_     Format: &#x60;bbox:{west longitude},{south latitude},{east longitude},{north latitude}&#x60;     Example: &#x60;bbox:13.08836,52.33812,13.761,52.6755&#x60;   The following constraints apply:   * Parameters \&quot;at\&quot;, \&quot;in&#x3D;circle\&quot; and \&quot;in&#x3D;bbox\&quot; are mutually exclusive. Only one of them is allowed.    * One of \&quot;at\&quot;, \&quot;in&#x3D;circle\&quot; or \&quot;in&#x3D;bbox\&quot; is required.   * The \&quot;in&#x3D;countryCode\&quot; parameter must be accompanied by exactly one of \&quot;at\&quot;, \&quot;in&#x3D;circle\&quot; or \&quot;in&#x3D;bbox\&quot;. (optional)
     * @param  int $limit Maximum number of results to be returned. (optional, default to 20)
     * @param  string $route BETA: Select within a geographic corridor. This is a hard filter. Results will be returned if they are located within the specified area.  A &#x60;route&#x60; is defined by a [Flexible Polyline Encoding](https://github.com/heremaps/flexible-polyline),  followed by an optional width, represented by a sub-parameter \&quot;w\&quot;.   Format: &#x60;{route};w&#x3D;{width}&#x60;  In regular expression syntax, the values of &#x60;route&#x60; look like:  &#x60;[a-zA-Z0-9_-]+(;w&#x3D;\\d+)?&#x60;  \&quot;[a-zA-Z0-9._-]+\&quot; is the encoded flexible polyline.  \&quot;w&#x3D;\\d+\&quot; is the optional width. The width is specified in meters from the center of the path. If no width is provided, the default is 1000 meters.  Type: &#x60;{Flexible Polyline Encoding};w&#x3D;{integer}&#x60;  Examples:  * &#x60;BFoz5xJ67i1B1B7PzIhaxL7Y&#x60;  * &#x60;BFoz5xJ67i1B1B7PzIhaxL7Y;w&#x3D;5000&#x60;  * &#x60;BlD05xgKuy2xCCx9B7vUCl0OhnRC54EqSCzpEl-HCxjD3pBCiGnyGCi2CvwFCsgD3nDC4vB6eC;w&#x3D;2000&#x60;  Note: The last example above can be decoded (using the Python class [here](https://github.com/heremaps/flexible-polyline/tree/master/python) as follows:  &#x60;&#x60;&#x60; &gt;&gt;&gt; import flexpolyline &gt;&gt;&gt; polyline &#x3D; &#39;BlD05xgKuy2xCCx9B7vUCl0OhnRC54EqSCzpEl-HCxjD3pBCiGnyGCi2CvwFCsgD3nDC4vB6eC&#39; &gt;&gt;&gt; flexpolyline.decode(polyline) [(52.51994, 13.38663, 1.0), (52.51009, 13.28169, 2.0), (52.43518, 13.19352, 3.0), (52.41073, 13.19645, 4.0), (52.38871, 13.15578, 5.0), (52.37278, 13.1491, 6.0), (52.37375, 13.11546, 7.0), (52.38752, 13.08722, 8.0), (52.40294, 13.07062, 9.0), (52.41058, 13.07555, 10.0)] &#x60;&#x60;&#x60; (optional)
     * @param  int $terms_limit BETA: Maximum number of Query Terms Suggestions to be returned. (optional)
     * @param  string $lang Select the language to be used for result rendering from a list of [BCP 47](https://en.wikipedia.org/wiki/IETF_language_tag) compliant language codes. (optional)
     * @param  string[] $show Select additional fields to be rendered in the response. Please note that some of the fields involve additional webservice calls and can increase the overall response time.  The value is a comma-separated list of the sections to be enabled. For each section there is a long and a short version of its id.  Description of accepted values:  &#39;details&#39;: Renders address and contact details, as well as opening hours of the searched place.  &#39;phonemes&#39;: Renders phonemes for address and place names into the results. (optional)
     * @param  string $x_request_id Used to correlate requests with their responses within a customer&#39;s application, for logging and error reporting.  Format: Free string, but a valid UUIDv4 is recommended. (optional)
     *
     * @throws \Here\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Here\Model\OpenSearchAutosuggestResponse|\Here\Model\ErrorResponse|\Here\Model\ErrorResponse|\Here\Model\ErrorResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function autosuggestGetWithHttpInfo($q, $at = null, $in = null, $limit = 20, $route = null, $terms_limit = null, $lang = null, $show = null, $x_request_id = null)
    {
        $request = $this->autosuggestGetRequest($q, $at, $in, $limit, $route, $terms_limit, $lang, $show, $x_request_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\Here\Model\OpenSearchAutosuggestResponse' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Here\Model\OpenSearchAutosuggestResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    if ('\Here\Model\ErrorResponse' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Here\Model\ErrorResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 405:
                    if ('\Here\Model\ErrorResponse' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Here\Model\ErrorResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 503:
                    if ('\Here\Model\ErrorResponse' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Here\Model\ErrorResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Here\Model\OpenSearchAutosuggestResponse';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Here\Model\OpenSearchAutosuggestResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Here\Model\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 405:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Here\Model\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 503:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Here\Model\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation autosuggestGetAsync
     *
     * Autosuggest
     *
     * This oepration contains host(s) defined in the OpenAP spec. Use 'hostIndex' to select the host.
     * URL: https://autosuggest.search.hereapi.com/v1
     *
     * @param  string $q Enter a free-text query  Examples:  * &#x60;res&#x60;, &#x60;rest&#x60;, &#x60;resta&#x60;, &#x60;restau&#x60;, ...  * &#x60;berlin+bran&#x60;, &#x60;berlin+brand&#x60;, &#x60;berlin+branden&#x60;, ...  * &#x60;New+Yok+Giants&#x60;   _Note: Whitespace, urls, email addresses, or other out-of-scope queries will yield no results. (required)
     * @param  string $at Specify the center of the search context expressed as coordinates  Format: &#x60;{latitude},{longitude}&#x60;  Type: &#x60;{decimal},{decimal}&#x60;  Example: &#x60;-13.163068,-72.545128&#x60; (Machu Picchu Mountain, Peru)  The following constraints apply:   * One of \&quot;at\&quot;, \&quot;in&#x3D;circle\&quot; or \&quot;in&#x3D;bbox\&quot; is required.   * Parameters \&quot;at\&quot;, \&quot;in&#x3D;circle\&quot; and \&quot;in&#x3D;bbox\&quot; are mutually exclusive. Only one of them is allowed. (optional)
     * @param  string $in Search within a geographic area. This is a hard filter. Results will be returned if they are located within the specified area.  A geographic area can be   * a country (or multiple countries), provided as comma-separated [ISO 3166-1 alpha-3](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-3) country codes     The country codes are to be provided in all uppercase.     Format: &#x60;countryCode:{countryCode}[,{countryCode}]*&#x60;     Examples:     * &#x60;countryCode:USA&#x60;     * &#x60;countryCode:CAN,MEX,USA&#x60;    * a circular area, provided as latitude, longitude, and radius (in meters)     Format: &#x60;circle:{latitude},{longitude};r&#x3D;{radius}&#x60;     Type: &#x60;circle:{decimal},{decimal};r&#x3D;{integer}&#x60;     Example: &#x60;circle:52.53,13.38;r&#x3D;10000&#x60;    * a bounding box, provided as _west longitude_, _south latitude_, _east longitude_, _north latitude_     Format: &#x60;bbox:{west longitude},{south latitude},{east longitude},{north latitude}&#x60;     Example: &#x60;bbox:13.08836,52.33812,13.761,52.6755&#x60;   The following constraints apply:   * Parameters \&quot;at\&quot;, \&quot;in&#x3D;circle\&quot; and \&quot;in&#x3D;bbox\&quot; are mutually exclusive. Only one of them is allowed.    * One of \&quot;at\&quot;, \&quot;in&#x3D;circle\&quot; or \&quot;in&#x3D;bbox\&quot; is required.   * The \&quot;in&#x3D;countryCode\&quot; parameter must be accompanied by exactly one of \&quot;at\&quot;, \&quot;in&#x3D;circle\&quot; or \&quot;in&#x3D;bbox\&quot;. (optional)
     * @param  int $limit Maximum number of results to be returned. (optional, default to 20)
     * @param  string $route BETA: Select within a geographic corridor. This is a hard filter. Results will be returned if they are located within the specified area.  A &#x60;route&#x60; is defined by a [Flexible Polyline Encoding](https://github.com/heremaps/flexible-polyline),  followed by an optional width, represented by a sub-parameter \&quot;w\&quot;.   Format: &#x60;{route};w&#x3D;{width}&#x60;  In regular expression syntax, the values of &#x60;route&#x60; look like:  &#x60;[a-zA-Z0-9_-]+(;w&#x3D;\\d+)?&#x60;  \&quot;[a-zA-Z0-9._-]+\&quot; is the encoded flexible polyline.  \&quot;w&#x3D;\\d+\&quot; is the optional width. The width is specified in meters from the center of the path. If no width is provided, the default is 1000 meters.  Type: &#x60;{Flexible Polyline Encoding};w&#x3D;{integer}&#x60;  Examples:  * &#x60;BFoz5xJ67i1B1B7PzIhaxL7Y&#x60;  * &#x60;BFoz5xJ67i1B1B7PzIhaxL7Y;w&#x3D;5000&#x60;  * &#x60;BlD05xgKuy2xCCx9B7vUCl0OhnRC54EqSCzpEl-HCxjD3pBCiGnyGCi2CvwFCsgD3nDC4vB6eC;w&#x3D;2000&#x60;  Note: The last example above can be decoded (using the Python class [here](https://github.com/heremaps/flexible-polyline/tree/master/python) as follows:  &#x60;&#x60;&#x60; &gt;&gt;&gt; import flexpolyline &gt;&gt;&gt; polyline &#x3D; &#39;BlD05xgKuy2xCCx9B7vUCl0OhnRC54EqSCzpEl-HCxjD3pBCiGnyGCi2CvwFCsgD3nDC4vB6eC&#39; &gt;&gt;&gt; flexpolyline.decode(polyline) [(52.51994, 13.38663, 1.0), (52.51009, 13.28169, 2.0), (52.43518, 13.19352, 3.0), (52.41073, 13.19645, 4.0), (52.38871, 13.15578, 5.0), (52.37278, 13.1491, 6.0), (52.37375, 13.11546, 7.0), (52.38752, 13.08722, 8.0), (52.40294, 13.07062, 9.0), (52.41058, 13.07555, 10.0)] &#x60;&#x60;&#x60; (optional)
     * @param  int $terms_limit BETA: Maximum number of Query Terms Suggestions to be returned. (optional)
     * @param  string $lang Select the language to be used for result rendering from a list of [BCP 47](https://en.wikipedia.org/wiki/IETF_language_tag) compliant language codes. (optional)
     * @param  string[] $show Select additional fields to be rendered in the response. Please note that some of the fields involve additional webservice calls and can increase the overall response time.  The value is a comma-separated list of the sections to be enabled. For each section there is a long and a short version of its id.  Description of accepted values:  &#39;details&#39;: Renders address and contact details, as well as opening hours of the searched place.  &#39;phonemes&#39;: Renders phonemes for address and place names into the results. (optional)
     * @param  string $x_request_id Used to correlate requests with their responses within a customer&#39;s application, for logging and error reporting.  Format: Free string, but a valid UUIDv4 is recommended. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function autosuggestGetAsync($q, $at = null, $in = null, $limit = 20, $route = null, $terms_limit = null, $lang = null, $show = null, $x_request_id = null)
    {
        return $this->autosuggestGetAsyncWithHttpInfo($q, $at, $in, $limit, $route, $terms_limit, $lang, $show, $x_request_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation autosuggestGetAsyncWithHttpInfo
     *
     * Autosuggest
     *
     * This oepration contains host(s) defined in the OpenAP spec. Use 'hostIndex' to select the host.
     * URL: https://autosuggest.search.hereapi.com/v1
     *
     * @param  string $q Enter a free-text query  Examples:  * &#x60;res&#x60;, &#x60;rest&#x60;, &#x60;resta&#x60;, &#x60;restau&#x60;, ...  * &#x60;berlin+bran&#x60;, &#x60;berlin+brand&#x60;, &#x60;berlin+branden&#x60;, ...  * &#x60;New+Yok+Giants&#x60;   _Note: Whitespace, urls, email addresses, or other out-of-scope queries will yield no results. (required)
     * @param  string $at Specify the center of the search context expressed as coordinates  Format: &#x60;{latitude},{longitude}&#x60;  Type: &#x60;{decimal},{decimal}&#x60;  Example: &#x60;-13.163068,-72.545128&#x60; (Machu Picchu Mountain, Peru)  The following constraints apply:   * One of \&quot;at\&quot;, \&quot;in&#x3D;circle\&quot; or \&quot;in&#x3D;bbox\&quot; is required.   * Parameters \&quot;at\&quot;, \&quot;in&#x3D;circle\&quot; and \&quot;in&#x3D;bbox\&quot; are mutually exclusive. Only one of them is allowed. (optional)
     * @param  string $in Search within a geographic area. This is a hard filter. Results will be returned if they are located within the specified area.  A geographic area can be   * a country (or multiple countries), provided as comma-separated [ISO 3166-1 alpha-3](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-3) country codes     The country codes are to be provided in all uppercase.     Format: &#x60;countryCode:{countryCode}[,{countryCode}]*&#x60;     Examples:     * &#x60;countryCode:USA&#x60;     * &#x60;countryCode:CAN,MEX,USA&#x60;    * a circular area, provided as latitude, longitude, and radius (in meters)     Format: &#x60;circle:{latitude},{longitude};r&#x3D;{radius}&#x60;     Type: &#x60;circle:{decimal},{decimal};r&#x3D;{integer}&#x60;     Example: &#x60;circle:52.53,13.38;r&#x3D;10000&#x60;    * a bounding box, provided as _west longitude_, _south latitude_, _east longitude_, _north latitude_     Format: &#x60;bbox:{west longitude},{south latitude},{east longitude},{north latitude}&#x60;     Example: &#x60;bbox:13.08836,52.33812,13.761,52.6755&#x60;   The following constraints apply:   * Parameters \&quot;at\&quot;, \&quot;in&#x3D;circle\&quot; and \&quot;in&#x3D;bbox\&quot; are mutually exclusive. Only one of them is allowed.    * One of \&quot;at\&quot;, \&quot;in&#x3D;circle\&quot; or \&quot;in&#x3D;bbox\&quot; is required.   * The \&quot;in&#x3D;countryCode\&quot; parameter must be accompanied by exactly one of \&quot;at\&quot;, \&quot;in&#x3D;circle\&quot; or \&quot;in&#x3D;bbox\&quot;. (optional)
     * @param  int $limit Maximum number of results to be returned. (optional, default to 20)
     * @param  string $route BETA: Select within a geographic corridor. This is a hard filter. Results will be returned if they are located within the specified area.  A &#x60;route&#x60; is defined by a [Flexible Polyline Encoding](https://github.com/heremaps/flexible-polyline),  followed by an optional width, represented by a sub-parameter \&quot;w\&quot;.   Format: &#x60;{route};w&#x3D;{width}&#x60;  In regular expression syntax, the values of &#x60;route&#x60; look like:  &#x60;[a-zA-Z0-9_-]+(;w&#x3D;\\d+)?&#x60;  \&quot;[a-zA-Z0-9._-]+\&quot; is the encoded flexible polyline.  \&quot;w&#x3D;\\d+\&quot; is the optional width. The width is specified in meters from the center of the path. If no width is provided, the default is 1000 meters.  Type: &#x60;{Flexible Polyline Encoding};w&#x3D;{integer}&#x60;  Examples:  * &#x60;BFoz5xJ67i1B1B7PzIhaxL7Y&#x60;  * &#x60;BFoz5xJ67i1B1B7PzIhaxL7Y;w&#x3D;5000&#x60;  * &#x60;BlD05xgKuy2xCCx9B7vUCl0OhnRC54EqSCzpEl-HCxjD3pBCiGnyGCi2CvwFCsgD3nDC4vB6eC;w&#x3D;2000&#x60;  Note: The last example above can be decoded (using the Python class [here](https://github.com/heremaps/flexible-polyline/tree/master/python) as follows:  &#x60;&#x60;&#x60; &gt;&gt;&gt; import flexpolyline &gt;&gt;&gt; polyline &#x3D; &#39;BlD05xgKuy2xCCx9B7vUCl0OhnRC54EqSCzpEl-HCxjD3pBCiGnyGCi2CvwFCsgD3nDC4vB6eC&#39; &gt;&gt;&gt; flexpolyline.decode(polyline) [(52.51994, 13.38663, 1.0), (52.51009, 13.28169, 2.0), (52.43518, 13.19352, 3.0), (52.41073, 13.19645, 4.0), (52.38871, 13.15578, 5.0), (52.37278, 13.1491, 6.0), (52.37375, 13.11546, 7.0), (52.38752, 13.08722, 8.0), (52.40294, 13.07062, 9.0), (52.41058, 13.07555, 10.0)] &#x60;&#x60;&#x60; (optional)
     * @param  int $terms_limit BETA: Maximum number of Query Terms Suggestions to be returned. (optional)
     * @param  string $lang Select the language to be used for result rendering from a list of [BCP 47](https://en.wikipedia.org/wiki/IETF_language_tag) compliant language codes. (optional)
     * @param  string[] $show Select additional fields to be rendered in the response. Please note that some of the fields involve additional webservice calls and can increase the overall response time.  The value is a comma-separated list of the sections to be enabled. For each section there is a long and a short version of its id.  Description of accepted values:  &#39;details&#39;: Renders address and contact details, as well as opening hours of the searched place.  &#39;phonemes&#39;: Renders phonemes for address and place names into the results. (optional)
     * @param  string $x_request_id Used to correlate requests with their responses within a customer&#39;s application, for logging and error reporting.  Format: Free string, but a valid UUIDv4 is recommended. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function autosuggestGetAsyncWithHttpInfo($q, $at = null, $in = null, $limit = 20, $route = null, $terms_limit = null, $lang = null, $show = null, $x_request_id = null)
    {
        $returnType = '\Here\Model\OpenSearchAutosuggestResponse';
        $request = $this->autosuggestGetRequest($q, $at, $in, $limit, $route, $terms_limit, $lang, $show, $x_request_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'autosuggestGet'
     *
     * This oepration contains host(s) defined in the OpenAP spec. Use 'hostIndex' to select the host.
     * URL: https://autosuggest.search.hereapi.com/v1
     *
     * @param  string $q Enter a free-text query  Examples:  * &#x60;res&#x60;, &#x60;rest&#x60;, &#x60;resta&#x60;, &#x60;restau&#x60;, ...  * &#x60;berlin+bran&#x60;, &#x60;berlin+brand&#x60;, &#x60;berlin+branden&#x60;, ...  * &#x60;New+Yok+Giants&#x60;   _Note: Whitespace, urls, email addresses, or other out-of-scope queries will yield no results. (required)
     * @param  string $at Specify the center of the search context expressed as coordinates  Format: &#x60;{latitude},{longitude}&#x60;  Type: &#x60;{decimal},{decimal}&#x60;  Example: &#x60;-13.163068,-72.545128&#x60; (Machu Picchu Mountain, Peru)  The following constraints apply:   * One of \&quot;at\&quot;, \&quot;in&#x3D;circle\&quot; or \&quot;in&#x3D;bbox\&quot; is required.   * Parameters \&quot;at\&quot;, \&quot;in&#x3D;circle\&quot; and \&quot;in&#x3D;bbox\&quot; are mutually exclusive. Only one of them is allowed. (optional)
     * @param  string $in Search within a geographic area. This is a hard filter. Results will be returned if they are located within the specified area.  A geographic area can be   * a country (or multiple countries), provided as comma-separated [ISO 3166-1 alpha-3](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-3) country codes     The country codes are to be provided in all uppercase.     Format: &#x60;countryCode:{countryCode}[,{countryCode}]*&#x60;     Examples:     * &#x60;countryCode:USA&#x60;     * &#x60;countryCode:CAN,MEX,USA&#x60;    * a circular area, provided as latitude, longitude, and radius (in meters)     Format: &#x60;circle:{latitude},{longitude};r&#x3D;{radius}&#x60;     Type: &#x60;circle:{decimal},{decimal};r&#x3D;{integer}&#x60;     Example: &#x60;circle:52.53,13.38;r&#x3D;10000&#x60;    * a bounding box, provided as _west longitude_, _south latitude_, _east longitude_, _north latitude_     Format: &#x60;bbox:{west longitude},{south latitude},{east longitude},{north latitude}&#x60;     Example: &#x60;bbox:13.08836,52.33812,13.761,52.6755&#x60;   The following constraints apply:   * Parameters \&quot;at\&quot;, \&quot;in&#x3D;circle\&quot; and \&quot;in&#x3D;bbox\&quot; are mutually exclusive. Only one of them is allowed.    * One of \&quot;at\&quot;, \&quot;in&#x3D;circle\&quot; or \&quot;in&#x3D;bbox\&quot; is required.   * The \&quot;in&#x3D;countryCode\&quot; parameter must be accompanied by exactly one of \&quot;at\&quot;, \&quot;in&#x3D;circle\&quot; or \&quot;in&#x3D;bbox\&quot;. (optional)
     * @param  int $limit Maximum number of results to be returned. (optional, default to 20)
     * @param  string $route BETA: Select within a geographic corridor. This is a hard filter. Results will be returned if they are located within the specified area.  A &#x60;route&#x60; is defined by a [Flexible Polyline Encoding](https://github.com/heremaps/flexible-polyline),  followed by an optional width, represented by a sub-parameter \&quot;w\&quot;.   Format: &#x60;{route};w&#x3D;{width}&#x60;  In regular expression syntax, the values of &#x60;route&#x60; look like:  &#x60;[a-zA-Z0-9_-]+(;w&#x3D;\\d+)?&#x60;  \&quot;[a-zA-Z0-9._-]+\&quot; is the encoded flexible polyline.  \&quot;w&#x3D;\\d+\&quot; is the optional width. The width is specified in meters from the center of the path. If no width is provided, the default is 1000 meters.  Type: &#x60;{Flexible Polyline Encoding};w&#x3D;{integer}&#x60;  Examples:  * &#x60;BFoz5xJ67i1B1B7PzIhaxL7Y&#x60;  * &#x60;BFoz5xJ67i1B1B7PzIhaxL7Y;w&#x3D;5000&#x60;  * &#x60;BlD05xgKuy2xCCx9B7vUCl0OhnRC54EqSCzpEl-HCxjD3pBCiGnyGCi2CvwFCsgD3nDC4vB6eC;w&#x3D;2000&#x60;  Note: The last example above can be decoded (using the Python class [here](https://github.com/heremaps/flexible-polyline/tree/master/python) as follows:  &#x60;&#x60;&#x60; &gt;&gt;&gt; import flexpolyline &gt;&gt;&gt; polyline &#x3D; &#39;BlD05xgKuy2xCCx9B7vUCl0OhnRC54EqSCzpEl-HCxjD3pBCiGnyGCi2CvwFCsgD3nDC4vB6eC&#39; &gt;&gt;&gt; flexpolyline.decode(polyline) [(52.51994, 13.38663, 1.0), (52.51009, 13.28169, 2.0), (52.43518, 13.19352, 3.0), (52.41073, 13.19645, 4.0), (52.38871, 13.15578, 5.0), (52.37278, 13.1491, 6.0), (52.37375, 13.11546, 7.0), (52.38752, 13.08722, 8.0), (52.40294, 13.07062, 9.0), (52.41058, 13.07555, 10.0)] &#x60;&#x60;&#x60; (optional)
     * @param  int $terms_limit BETA: Maximum number of Query Terms Suggestions to be returned. (optional)
     * @param  string $lang Select the language to be used for result rendering from a list of [BCP 47](https://en.wikipedia.org/wiki/IETF_language_tag) compliant language codes. (optional)
     * @param  string[] $show Select additional fields to be rendered in the response. Please note that some of the fields involve additional webservice calls and can increase the overall response time.  The value is a comma-separated list of the sections to be enabled. For each section there is a long and a short version of its id.  Description of accepted values:  &#39;details&#39;: Renders address and contact details, as well as opening hours of the searched place.  &#39;phonemes&#39;: Renders phonemes for address and place names into the results. (optional)
     * @param  string $x_request_id Used to correlate requests with their responses within a customer&#39;s application, for logging and error reporting.  Format: Free string, but a valid UUIDv4 is recommended. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function autosuggestGetRequest($q, $at = null, $in = null, $limit = 20, $route = null, $terms_limit = null, $lang = null, $show = null, $x_request_id = null)
    {
        // verify the required parameter 'q' is set
        if ($q === null || (is_array($q) && count($q) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $q when calling autosuggestGet'
            );
        }
        if ($limit !== null && $limit > 100) {
            throw new \InvalidArgumentException('invalid value for "$limit" when calling DefaultApi.autosuggestGet, must be smaller than or equal to 100.');
        }
        if ($limit !== null && $limit < 1) {
            throw new \InvalidArgumentException('invalid value for "$limit" when calling DefaultApi.autosuggestGet, must be bigger than or equal to 1.');
        }

        if ($terms_limit !== null && $terms_limit > 10) {
            throw new \InvalidArgumentException('invalid value for "$terms_limit" when calling DefaultApi.autosuggestGet, must be smaller than or equal to 10.');
        }
        if ($terms_limit !== null && $terms_limit < 0) {
            throw new \InvalidArgumentException('invalid value for "$terms_limit" when calling DefaultApi.autosuggestGet, must be bigger than or equal to 0.');
        }


        $resourcePath = '/autosuggest';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($q !== null) {
            if('form' === 'form' && is_array($q)) {
                foreach($q as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['q'] = $q;
            }
        }
        // query params
        if ($at !== null) {
            if('form' === 'form' && is_array($at)) {
                foreach($at as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['at'] = $at;
            }
        }
        // query params
        if ($in !== null) {
            if('form' === 'form' && is_array($in)) {
                foreach($in as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['in'] = $in;
            }
        }
        // query params
        if ($limit !== null) {
            if('form' === 'form' && is_array($limit)) {
                foreach($limit as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['limit'] = $limit;
            }
        }
        // query params
        if ($route !== null) {
            if('form' === 'form' && is_array($route)) {
                foreach($route as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['route'] = $route;
            }
        }
        // query params
        if ($terms_limit !== null) {
            if('form' === 'form' && is_array($terms_limit)) {
                foreach($terms_limit as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['termsLimit'] = $terms_limit;
            }
        }
        // query params
        if ($lang !== null) {
            if('form' === 'form' && is_array($lang)) {
                foreach($lang as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['lang'] = $lang;
            }
        }
        // query params
        if (is_array($show)) {
            $show = ObjectSerializer::serializeCollection($show, 'form', true);
        }
        if ($show !== null) {
            $queryParams['show'] = $show;
        }

        // header params
        if ($x_request_id !== null) {
            $headerParams['X-Request-ID'] = ObjectSerializer::toHeaderValue($x_request_id);
        }



        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('apiKey');
        if ($apiKey !== null) {
            $queryParams['apiKey'] = $apiKey;
        }
        // this endpoint requires Bearer (JWT) authentication (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHosts = ["https://autosuggest.search.hereapi.com/v1"];
        if ($this->hostIndex < 0 || $this->hostIndex >= sizeof($operationHosts)) {
            throw new \InvalidArgumentException("Invalid index {$this->hostIndex} when selecting the host. Must be less than ".sizeof($operationHosts));
        }
        $operationHost = $operationHosts[$this->hostIndex];

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation browseGet
     *
     * Browse
     *
     * This oepration contains host(s) defined in the OpenAP spec. Use 'hostIndex' to select the host.
     * URL: https://browse.search.hereapi.com/v1
     *
     * @param  string $at Specify the center of the search context expressed as coordinates  Required parameter for endpoints that are expected to rank results by distance from the explicitly  specified search center  Format: &#x60;{latitude},{longitude}&#x60;  Type: &#x60;{decimal},{decimal}&#x60;  Example: &#x60;-13.163068,-72.545128&#x60; (Machu Picchu Mountain, Peru) (required)
     * @param  string $categories Category filter consisting of a comma-separated list of category-Ids for Categories defined in the HERE Places Category System, described in the Appendix to the HERE Search Developer Guide. Places with any assigned categories that match any of the requested categories are included in the response. (optional)
     * @param  string $in Search within a geographic area. This is a hard filter. Results will be returned if they are located within the specified area.  A geographic area can be   * a country (or multiple countries), provided as comma-separated [ISO 3166-1 alpha-3](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-3) country codes     The country codes are to be provided in all uppercase.     Format: &#x60;countryCode:{countryCode}[,{countryCode}]*&#x60;     Examples:     * &#x60;countryCode:USA&#x60;     * &#x60;countryCode:CAN,MEX,USA&#x60;    * a circular area, provided as latitude, longitude, and radius (in meters)     Format: &#x60;circle:{latitude},{longitude};r&#x3D;{radius}&#x60;     Type: &#x60;circle:{decimal},{decimal};r&#x3D;{integer}&#x60;     Example: &#x60;circle:52.53,13.38;r&#x3D;10000&#x60;    * a bounding box, provided as _west longitude_, _south latitude_, _east longitude_, _north latitude_     Format: &#x60;bbox:{west longitude},{south latitude},{east longitude},{north latitude}&#x60;     Example: &#x60;bbox:13.08836,52.33812,13.761,52.6755&#x60;   The following constraints apply:   * Parameters \&quot;in&#x3D;circle\&quot; and \&quot;in&#x3D;bbox\&quot; are mutually exclusive. Only one of them is allowed. (optional)
     * @param  int $limit Maximum number of results to be returned. (optional, default to 20)
     * @param  string $name Full-text filter on POI names/titles. Results with a partial match on the name parameter are included in the response. (optional)
     * @param  string $route BETA: Select within a geographic corridor. This is a hard filter. Results will be returned if they are located within the specified area.  A &#x60;route&#x60; is defined by a [Flexible Polyline Encoding](https://github.com/heremaps/flexible-polyline),  followed by an optional width, represented by a sub-parameter \&quot;w\&quot;.   Format: &#x60;{route};w&#x3D;{width}&#x60;  In regular expression syntax, the values of &#x60;route&#x60; look like:  &#x60;[a-zA-Z0-9_-]+(;w&#x3D;\\d+)?&#x60;  \&quot;[a-zA-Z0-9._-]+\&quot; is the encoded flexible polyline.  \&quot;w&#x3D;\\d+\&quot; is the optional width. The width is specified in meters from the center of the path. If no width is provided, the default is 1000 meters.  Type: &#x60;{Flexible Polyline Encoding};w&#x3D;{integer}&#x60;  Examples:  * &#x60;BFoz5xJ67i1B1B7PzIhaxL7Y&#x60;  * &#x60;BFoz5xJ67i1B1B7PzIhaxL7Y;w&#x3D;5000&#x60;  * &#x60;BlD05xgKuy2xCCx9B7vUCl0OhnRC54EqSCzpEl-HCxjD3pBCiGnyGCi2CvwFCsgD3nDC4vB6eC;w&#x3D;2000&#x60;  Note: The last example above can be decoded (using the Python class [here](https://github.com/heremaps/flexible-polyline/tree/master/python) as follows:  &#x60;&#x60;&#x60; &gt;&gt;&gt; import flexpolyline &gt;&gt;&gt; polyline &#x3D; &#39;BlD05xgKuy2xCCx9B7vUCl0OhnRC54EqSCzpEl-HCxjD3pBCiGnyGCi2CvwFCsgD3nDC4vB6eC&#39; &gt;&gt;&gt; flexpolyline.decode(polyline) [(52.51994, 13.38663, 1.0), (52.51009, 13.28169, 2.0), (52.43518, 13.19352, 3.0), (52.41073, 13.19645, 4.0), (52.38871, 13.15578, 5.0), (52.37278, 13.1491, 6.0), (52.37375, 13.11546, 7.0), (52.38752, 13.08722, 8.0), (52.40294, 13.07062, 9.0), (52.41058, 13.07555, 10.0)] &#x60;&#x60;&#x60; (optional)
     * @param  string $lang Select the language to be used for result rendering from a list of [BCP 47](https://en.wikipedia.org/wiki/IETF_language_tag) compliant language codes. (optional)
     * @param  string[] $show Select additional fields to be rendered in the response. Please note that some of the fields involve additional webservice calls and can increase the overall response time.  The value is a comma-separated list of the sections to be enabled. For each section there is a long and a short version of its id.  Description of accepted values:  &#39;phonemes&#39;: Renders phonemes for address and place names into the results. (optional)
     * @param  string $x_request_id Used to correlate requests with their responses within a customer&#39;s application, for logging and error reporting.  Format: Free string, but a valid UUIDv4 is recommended. (optional)
     *
     * @throws \Here\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Here\Model\OpenSearchBrowseResponse|\Here\Model\ErrorResponse|\Here\Model\ErrorResponse|\Here\Model\ErrorResponse
     */
    public function browseGet($at, $categories = null, $in = null, $limit = 20, $name = null, $route = null, $lang = null, $show = null, $x_request_id = null)
    {
        list($response) = $this->browseGetWithHttpInfo($at, $categories, $in, $limit, $name, $route, $lang, $show, $x_request_id);
        return $response;
    }

    /**
     * Operation browseGetWithHttpInfo
     *
     * Browse
     *
     * This oepration contains host(s) defined in the OpenAP spec. Use 'hostIndex' to select the host.
     * URL: https://browse.search.hereapi.com/v1
     *
     * @param  string $at Specify the center of the search context expressed as coordinates  Required parameter for endpoints that are expected to rank results by distance from the explicitly  specified search center  Format: &#x60;{latitude},{longitude}&#x60;  Type: &#x60;{decimal},{decimal}&#x60;  Example: &#x60;-13.163068,-72.545128&#x60; (Machu Picchu Mountain, Peru) (required)
     * @param  string $categories Category filter consisting of a comma-separated list of category-Ids for Categories defined in the HERE Places Category System, described in the Appendix to the HERE Search Developer Guide. Places with any assigned categories that match any of the requested categories are included in the response. (optional)
     * @param  string $in Search within a geographic area. This is a hard filter. Results will be returned if they are located within the specified area.  A geographic area can be   * a country (or multiple countries), provided as comma-separated [ISO 3166-1 alpha-3](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-3) country codes     The country codes are to be provided in all uppercase.     Format: &#x60;countryCode:{countryCode}[,{countryCode}]*&#x60;     Examples:     * &#x60;countryCode:USA&#x60;     * &#x60;countryCode:CAN,MEX,USA&#x60;    * a circular area, provided as latitude, longitude, and radius (in meters)     Format: &#x60;circle:{latitude},{longitude};r&#x3D;{radius}&#x60;     Type: &#x60;circle:{decimal},{decimal};r&#x3D;{integer}&#x60;     Example: &#x60;circle:52.53,13.38;r&#x3D;10000&#x60;    * a bounding box, provided as _west longitude_, _south latitude_, _east longitude_, _north latitude_     Format: &#x60;bbox:{west longitude},{south latitude},{east longitude},{north latitude}&#x60;     Example: &#x60;bbox:13.08836,52.33812,13.761,52.6755&#x60;   The following constraints apply:   * Parameters \&quot;in&#x3D;circle\&quot; and \&quot;in&#x3D;bbox\&quot; are mutually exclusive. Only one of them is allowed. (optional)
     * @param  int $limit Maximum number of results to be returned. (optional, default to 20)
     * @param  string $name Full-text filter on POI names/titles. Results with a partial match on the name parameter are included in the response. (optional)
     * @param  string $route BETA: Select within a geographic corridor. This is a hard filter. Results will be returned if they are located within the specified area.  A &#x60;route&#x60; is defined by a [Flexible Polyline Encoding](https://github.com/heremaps/flexible-polyline),  followed by an optional width, represented by a sub-parameter \&quot;w\&quot;.   Format: &#x60;{route};w&#x3D;{width}&#x60;  In regular expression syntax, the values of &#x60;route&#x60; look like:  &#x60;[a-zA-Z0-9_-]+(;w&#x3D;\\d+)?&#x60;  \&quot;[a-zA-Z0-9._-]+\&quot; is the encoded flexible polyline.  \&quot;w&#x3D;\\d+\&quot; is the optional width. The width is specified in meters from the center of the path. If no width is provided, the default is 1000 meters.  Type: &#x60;{Flexible Polyline Encoding};w&#x3D;{integer}&#x60;  Examples:  * &#x60;BFoz5xJ67i1B1B7PzIhaxL7Y&#x60;  * &#x60;BFoz5xJ67i1B1B7PzIhaxL7Y;w&#x3D;5000&#x60;  * &#x60;BlD05xgKuy2xCCx9B7vUCl0OhnRC54EqSCzpEl-HCxjD3pBCiGnyGCi2CvwFCsgD3nDC4vB6eC;w&#x3D;2000&#x60;  Note: The last example above can be decoded (using the Python class [here](https://github.com/heremaps/flexible-polyline/tree/master/python) as follows:  &#x60;&#x60;&#x60; &gt;&gt;&gt; import flexpolyline &gt;&gt;&gt; polyline &#x3D; &#39;BlD05xgKuy2xCCx9B7vUCl0OhnRC54EqSCzpEl-HCxjD3pBCiGnyGCi2CvwFCsgD3nDC4vB6eC&#39; &gt;&gt;&gt; flexpolyline.decode(polyline) [(52.51994, 13.38663, 1.0), (52.51009, 13.28169, 2.0), (52.43518, 13.19352, 3.0), (52.41073, 13.19645, 4.0), (52.38871, 13.15578, 5.0), (52.37278, 13.1491, 6.0), (52.37375, 13.11546, 7.0), (52.38752, 13.08722, 8.0), (52.40294, 13.07062, 9.0), (52.41058, 13.07555, 10.0)] &#x60;&#x60;&#x60; (optional)
     * @param  string $lang Select the language to be used for result rendering from a list of [BCP 47](https://en.wikipedia.org/wiki/IETF_language_tag) compliant language codes. (optional)
     * @param  string[] $show Select additional fields to be rendered in the response. Please note that some of the fields involve additional webservice calls and can increase the overall response time.  The value is a comma-separated list of the sections to be enabled. For each section there is a long and a short version of its id.  Description of accepted values:  &#39;phonemes&#39;: Renders phonemes for address and place names into the results. (optional)
     * @param  string $x_request_id Used to correlate requests with their responses within a customer&#39;s application, for logging and error reporting.  Format: Free string, but a valid UUIDv4 is recommended. (optional)
     *
     * @throws \Here\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Here\Model\OpenSearchBrowseResponse|\Here\Model\ErrorResponse|\Here\Model\ErrorResponse|\Here\Model\ErrorResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function browseGetWithHttpInfo($at, $categories = null, $in = null, $limit = 20, $name = null, $route = null, $lang = null, $show = null, $x_request_id = null)
    {
        $request = $this->browseGetRequest($at, $categories, $in, $limit, $name, $route, $lang, $show, $x_request_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\Here\Model\OpenSearchBrowseResponse' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Here\Model\OpenSearchBrowseResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    if ('\Here\Model\ErrorResponse' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Here\Model\ErrorResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 405:
                    if ('\Here\Model\ErrorResponse' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Here\Model\ErrorResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 503:
                    if ('\Here\Model\ErrorResponse' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Here\Model\ErrorResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Here\Model\OpenSearchBrowseResponse';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Here\Model\OpenSearchBrowseResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Here\Model\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 405:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Here\Model\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 503:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Here\Model\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation browseGetAsync
     *
     * Browse
     *
     * This oepration contains host(s) defined in the OpenAP spec. Use 'hostIndex' to select the host.
     * URL: https://browse.search.hereapi.com/v1
     *
     * @param  string $at Specify the center of the search context expressed as coordinates  Required parameter for endpoints that are expected to rank results by distance from the explicitly  specified search center  Format: &#x60;{latitude},{longitude}&#x60;  Type: &#x60;{decimal},{decimal}&#x60;  Example: &#x60;-13.163068,-72.545128&#x60; (Machu Picchu Mountain, Peru) (required)
     * @param  string $categories Category filter consisting of a comma-separated list of category-Ids for Categories defined in the HERE Places Category System, described in the Appendix to the HERE Search Developer Guide. Places with any assigned categories that match any of the requested categories are included in the response. (optional)
     * @param  string $in Search within a geographic area. This is a hard filter. Results will be returned if they are located within the specified area.  A geographic area can be   * a country (or multiple countries), provided as comma-separated [ISO 3166-1 alpha-3](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-3) country codes     The country codes are to be provided in all uppercase.     Format: &#x60;countryCode:{countryCode}[,{countryCode}]*&#x60;     Examples:     * &#x60;countryCode:USA&#x60;     * &#x60;countryCode:CAN,MEX,USA&#x60;    * a circular area, provided as latitude, longitude, and radius (in meters)     Format: &#x60;circle:{latitude},{longitude};r&#x3D;{radius}&#x60;     Type: &#x60;circle:{decimal},{decimal};r&#x3D;{integer}&#x60;     Example: &#x60;circle:52.53,13.38;r&#x3D;10000&#x60;    * a bounding box, provided as _west longitude_, _south latitude_, _east longitude_, _north latitude_     Format: &#x60;bbox:{west longitude},{south latitude},{east longitude},{north latitude}&#x60;     Example: &#x60;bbox:13.08836,52.33812,13.761,52.6755&#x60;   The following constraints apply:   * Parameters \&quot;in&#x3D;circle\&quot; and \&quot;in&#x3D;bbox\&quot; are mutually exclusive. Only one of them is allowed. (optional)
     * @param  int $limit Maximum number of results to be returned. (optional, default to 20)
     * @param  string $name Full-text filter on POI names/titles. Results with a partial match on the name parameter are included in the response. (optional)
     * @param  string $route BETA: Select within a geographic corridor. This is a hard filter. Results will be returned if they are located within the specified area.  A &#x60;route&#x60; is defined by a [Flexible Polyline Encoding](https://github.com/heremaps/flexible-polyline),  followed by an optional width, represented by a sub-parameter \&quot;w\&quot;.   Format: &#x60;{route};w&#x3D;{width}&#x60;  In regular expression syntax, the values of &#x60;route&#x60; look like:  &#x60;[a-zA-Z0-9_-]+(;w&#x3D;\\d+)?&#x60;  \&quot;[a-zA-Z0-9._-]+\&quot; is the encoded flexible polyline.  \&quot;w&#x3D;\\d+\&quot; is the optional width. The width is specified in meters from the center of the path. If no width is provided, the default is 1000 meters.  Type: &#x60;{Flexible Polyline Encoding};w&#x3D;{integer}&#x60;  Examples:  * &#x60;BFoz5xJ67i1B1B7PzIhaxL7Y&#x60;  * &#x60;BFoz5xJ67i1B1B7PzIhaxL7Y;w&#x3D;5000&#x60;  * &#x60;BlD05xgKuy2xCCx9B7vUCl0OhnRC54EqSCzpEl-HCxjD3pBCiGnyGCi2CvwFCsgD3nDC4vB6eC;w&#x3D;2000&#x60;  Note: The last example above can be decoded (using the Python class [here](https://github.com/heremaps/flexible-polyline/tree/master/python) as follows:  &#x60;&#x60;&#x60; &gt;&gt;&gt; import flexpolyline &gt;&gt;&gt; polyline &#x3D; &#39;BlD05xgKuy2xCCx9B7vUCl0OhnRC54EqSCzpEl-HCxjD3pBCiGnyGCi2CvwFCsgD3nDC4vB6eC&#39; &gt;&gt;&gt; flexpolyline.decode(polyline) [(52.51994, 13.38663, 1.0), (52.51009, 13.28169, 2.0), (52.43518, 13.19352, 3.0), (52.41073, 13.19645, 4.0), (52.38871, 13.15578, 5.0), (52.37278, 13.1491, 6.0), (52.37375, 13.11546, 7.0), (52.38752, 13.08722, 8.0), (52.40294, 13.07062, 9.0), (52.41058, 13.07555, 10.0)] &#x60;&#x60;&#x60; (optional)
     * @param  string $lang Select the language to be used for result rendering from a list of [BCP 47](https://en.wikipedia.org/wiki/IETF_language_tag) compliant language codes. (optional)
     * @param  string[] $show Select additional fields to be rendered in the response. Please note that some of the fields involve additional webservice calls and can increase the overall response time.  The value is a comma-separated list of the sections to be enabled. For each section there is a long and a short version of its id.  Description of accepted values:  &#39;phonemes&#39;: Renders phonemes for address and place names into the results. (optional)
     * @param  string $x_request_id Used to correlate requests with their responses within a customer&#39;s application, for logging and error reporting.  Format: Free string, but a valid UUIDv4 is recommended. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function browseGetAsync($at, $categories = null, $in = null, $limit = 20, $name = null, $route = null, $lang = null, $show = null, $x_request_id = null)
    {
        return $this->browseGetAsyncWithHttpInfo($at, $categories, $in, $limit, $name, $route, $lang, $show, $x_request_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation browseGetAsyncWithHttpInfo
     *
     * Browse
     *
     * This oepration contains host(s) defined in the OpenAP spec. Use 'hostIndex' to select the host.
     * URL: https://browse.search.hereapi.com/v1
     *
     * @param  string $at Specify the center of the search context expressed as coordinates  Required parameter for endpoints that are expected to rank results by distance from the explicitly  specified search center  Format: &#x60;{latitude},{longitude}&#x60;  Type: &#x60;{decimal},{decimal}&#x60;  Example: &#x60;-13.163068,-72.545128&#x60; (Machu Picchu Mountain, Peru) (required)
     * @param  string $categories Category filter consisting of a comma-separated list of category-Ids for Categories defined in the HERE Places Category System, described in the Appendix to the HERE Search Developer Guide. Places with any assigned categories that match any of the requested categories are included in the response. (optional)
     * @param  string $in Search within a geographic area. This is a hard filter. Results will be returned if they are located within the specified area.  A geographic area can be   * a country (or multiple countries), provided as comma-separated [ISO 3166-1 alpha-3](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-3) country codes     The country codes are to be provided in all uppercase.     Format: &#x60;countryCode:{countryCode}[,{countryCode}]*&#x60;     Examples:     * &#x60;countryCode:USA&#x60;     * &#x60;countryCode:CAN,MEX,USA&#x60;    * a circular area, provided as latitude, longitude, and radius (in meters)     Format: &#x60;circle:{latitude},{longitude};r&#x3D;{radius}&#x60;     Type: &#x60;circle:{decimal},{decimal};r&#x3D;{integer}&#x60;     Example: &#x60;circle:52.53,13.38;r&#x3D;10000&#x60;    * a bounding box, provided as _west longitude_, _south latitude_, _east longitude_, _north latitude_     Format: &#x60;bbox:{west longitude},{south latitude},{east longitude},{north latitude}&#x60;     Example: &#x60;bbox:13.08836,52.33812,13.761,52.6755&#x60;   The following constraints apply:   * Parameters \&quot;in&#x3D;circle\&quot; and \&quot;in&#x3D;bbox\&quot; are mutually exclusive. Only one of them is allowed. (optional)
     * @param  int $limit Maximum number of results to be returned. (optional, default to 20)
     * @param  string $name Full-text filter on POI names/titles. Results with a partial match on the name parameter are included in the response. (optional)
     * @param  string $route BETA: Select within a geographic corridor. This is a hard filter. Results will be returned if they are located within the specified area.  A &#x60;route&#x60; is defined by a [Flexible Polyline Encoding](https://github.com/heremaps/flexible-polyline),  followed by an optional width, represented by a sub-parameter \&quot;w\&quot;.   Format: &#x60;{route};w&#x3D;{width}&#x60;  In regular expression syntax, the values of &#x60;route&#x60; look like:  &#x60;[a-zA-Z0-9_-]+(;w&#x3D;\\d+)?&#x60;  \&quot;[a-zA-Z0-9._-]+\&quot; is the encoded flexible polyline.  \&quot;w&#x3D;\\d+\&quot; is the optional width. The width is specified in meters from the center of the path. If no width is provided, the default is 1000 meters.  Type: &#x60;{Flexible Polyline Encoding};w&#x3D;{integer}&#x60;  Examples:  * &#x60;BFoz5xJ67i1B1B7PzIhaxL7Y&#x60;  * &#x60;BFoz5xJ67i1B1B7PzIhaxL7Y;w&#x3D;5000&#x60;  * &#x60;BlD05xgKuy2xCCx9B7vUCl0OhnRC54EqSCzpEl-HCxjD3pBCiGnyGCi2CvwFCsgD3nDC4vB6eC;w&#x3D;2000&#x60;  Note: The last example above can be decoded (using the Python class [here](https://github.com/heremaps/flexible-polyline/tree/master/python) as follows:  &#x60;&#x60;&#x60; &gt;&gt;&gt; import flexpolyline &gt;&gt;&gt; polyline &#x3D; &#39;BlD05xgKuy2xCCx9B7vUCl0OhnRC54EqSCzpEl-HCxjD3pBCiGnyGCi2CvwFCsgD3nDC4vB6eC&#39; &gt;&gt;&gt; flexpolyline.decode(polyline) [(52.51994, 13.38663, 1.0), (52.51009, 13.28169, 2.0), (52.43518, 13.19352, 3.0), (52.41073, 13.19645, 4.0), (52.38871, 13.15578, 5.0), (52.37278, 13.1491, 6.0), (52.37375, 13.11546, 7.0), (52.38752, 13.08722, 8.0), (52.40294, 13.07062, 9.0), (52.41058, 13.07555, 10.0)] &#x60;&#x60;&#x60; (optional)
     * @param  string $lang Select the language to be used for result rendering from a list of [BCP 47](https://en.wikipedia.org/wiki/IETF_language_tag) compliant language codes. (optional)
     * @param  string[] $show Select additional fields to be rendered in the response. Please note that some of the fields involve additional webservice calls and can increase the overall response time.  The value is a comma-separated list of the sections to be enabled. For each section there is a long and a short version of its id.  Description of accepted values:  &#39;phonemes&#39;: Renders phonemes for address and place names into the results. (optional)
     * @param  string $x_request_id Used to correlate requests with their responses within a customer&#39;s application, for logging and error reporting.  Format: Free string, but a valid UUIDv4 is recommended. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function browseGetAsyncWithHttpInfo($at, $categories = null, $in = null, $limit = 20, $name = null, $route = null, $lang = null, $show = null, $x_request_id = null)
    {
        $returnType = '\Here\Model\OpenSearchBrowseResponse';
        $request = $this->browseGetRequest($at, $categories, $in, $limit, $name, $route, $lang, $show, $x_request_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'browseGet'
     *
     * This oepration contains host(s) defined in the OpenAP spec. Use 'hostIndex' to select the host.
     * URL: https://browse.search.hereapi.com/v1
     *
     * @param  string $at Specify the center of the search context expressed as coordinates  Required parameter for endpoints that are expected to rank results by distance from the explicitly  specified search center  Format: &#x60;{latitude},{longitude}&#x60;  Type: &#x60;{decimal},{decimal}&#x60;  Example: &#x60;-13.163068,-72.545128&#x60; (Machu Picchu Mountain, Peru) (required)
     * @param  string $categories Category filter consisting of a comma-separated list of category-Ids for Categories defined in the HERE Places Category System, described in the Appendix to the HERE Search Developer Guide. Places with any assigned categories that match any of the requested categories are included in the response. (optional)
     * @param  string $in Search within a geographic area. This is a hard filter. Results will be returned if they are located within the specified area.  A geographic area can be   * a country (or multiple countries), provided as comma-separated [ISO 3166-1 alpha-3](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-3) country codes     The country codes are to be provided in all uppercase.     Format: &#x60;countryCode:{countryCode}[,{countryCode}]*&#x60;     Examples:     * &#x60;countryCode:USA&#x60;     * &#x60;countryCode:CAN,MEX,USA&#x60;    * a circular area, provided as latitude, longitude, and radius (in meters)     Format: &#x60;circle:{latitude},{longitude};r&#x3D;{radius}&#x60;     Type: &#x60;circle:{decimal},{decimal};r&#x3D;{integer}&#x60;     Example: &#x60;circle:52.53,13.38;r&#x3D;10000&#x60;    * a bounding box, provided as _west longitude_, _south latitude_, _east longitude_, _north latitude_     Format: &#x60;bbox:{west longitude},{south latitude},{east longitude},{north latitude}&#x60;     Example: &#x60;bbox:13.08836,52.33812,13.761,52.6755&#x60;   The following constraints apply:   * Parameters \&quot;in&#x3D;circle\&quot; and \&quot;in&#x3D;bbox\&quot; are mutually exclusive. Only one of them is allowed. (optional)
     * @param  int $limit Maximum number of results to be returned. (optional, default to 20)
     * @param  string $name Full-text filter on POI names/titles. Results with a partial match on the name parameter are included in the response. (optional)
     * @param  string $route BETA: Select within a geographic corridor. This is a hard filter. Results will be returned if they are located within the specified area.  A &#x60;route&#x60; is defined by a [Flexible Polyline Encoding](https://github.com/heremaps/flexible-polyline),  followed by an optional width, represented by a sub-parameter \&quot;w\&quot;.   Format: &#x60;{route};w&#x3D;{width}&#x60;  In regular expression syntax, the values of &#x60;route&#x60; look like:  &#x60;[a-zA-Z0-9_-]+(;w&#x3D;\\d+)?&#x60;  \&quot;[a-zA-Z0-9._-]+\&quot; is the encoded flexible polyline.  \&quot;w&#x3D;\\d+\&quot; is the optional width. The width is specified in meters from the center of the path. If no width is provided, the default is 1000 meters.  Type: &#x60;{Flexible Polyline Encoding};w&#x3D;{integer}&#x60;  Examples:  * &#x60;BFoz5xJ67i1B1B7PzIhaxL7Y&#x60;  * &#x60;BFoz5xJ67i1B1B7PzIhaxL7Y;w&#x3D;5000&#x60;  * &#x60;BlD05xgKuy2xCCx9B7vUCl0OhnRC54EqSCzpEl-HCxjD3pBCiGnyGCi2CvwFCsgD3nDC4vB6eC;w&#x3D;2000&#x60;  Note: The last example above can be decoded (using the Python class [here](https://github.com/heremaps/flexible-polyline/tree/master/python) as follows:  &#x60;&#x60;&#x60; &gt;&gt;&gt; import flexpolyline &gt;&gt;&gt; polyline &#x3D; &#39;BlD05xgKuy2xCCx9B7vUCl0OhnRC54EqSCzpEl-HCxjD3pBCiGnyGCi2CvwFCsgD3nDC4vB6eC&#39; &gt;&gt;&gt; flexpolyline.decode(polyline) [(52.51994, 13.38663, 1.0), (52.51009, 13.28169, 2.0), (52.43518, 13.19352, 3.0), (52.41073, 13.19645, 4.0), (52.38871, 13.15578, 5.0), (52.37278, 13.1491, 6.0), (52.37375, 13.11546, 7.0), (52.38752, 13.08722, 8.0), (52.40294, 13.07062, 9.0), (52.41058, 13.07555, 10.0)] &#x60;&#x60;&#x60; (optional)
     * @param  string $lang Select the language to be used for result rendering from a list of [BCP 47](https://en.wikipedia.org/wiki/IETF_language_tag) compliant language codes. (optional)
     * @param  string[] $show Select additional fields to be rendered in the response. Please note that some of the fields involve additional webservice calls and can increase the overall response time.  The value is a comma-separated list of the sections to be enabled. For each section there is a long and a short version of its id.  Description of accepted values:  &#39;phonemes&#39;: Renders phonemes for address and place names into the results. (optional)
     * @param  string $x_request_id Used to correlate requests with their responses within a customer&#39;s application, for logging and error reporting.  Format: Free string, but a valid UUIDv4 is recommended. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function browseGetRequest($at, $categories = null, $in = null, $limit = 20, $name = null, $route = null, $lang = null, $show = null, $x_request_id = null)
    {
        // verify the required parameter 'at' is set
        if ($at === null || (is_array($at) && count($at) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $at when calling browseGet'
            );
        }
        if ($limit !== null && $limit > 100) {
            throw new \InvalidArgumentException('invalid value for "$limit" when calling DefaultApi.browseGet, must be smaller than or equal to 100.');
        }
        if ($limit !== null && $limit < 1) {
            throw new \InvalidArgumentException('invalid value for "$limit" when calling DefaultApi.browseGet, must be bigger than or equal to 1.');
        }


        $resourcePath = '/browse';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($at !== null) {
            if('form' === 'form' && is_array($at)) {
                foreach($at as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['at'] = $at;
            }
        }
        // query params
        if ($categories !== null) {
            if('form' === 'form' && is_array($categories)) {
                foreach($categories as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['categories'] = $categories;
            }
        }
        // query params
        if ($in !== null) {
            if('form' === 'form' && is_array($in)) {
                foreach($in as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['in'] = $in;
            }
        }
        // query params
        if ($limit !== null) {
            if('form' === 'form' && is_array($limit)) {
                foreach($limit as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['limit'] = $limit;
            }
        }
        // query params
        if ($name !== null) {
            if('form' === 'form' && is_array($name)) {
                foreach($name as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['name'] = $name;
            }
        }
        // query params
        if ($route !== null) {
            if('form' === 'form' && is_array($route)) {
                foreach($route as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['route'] = $route;
            }
        }
        // query params
        if ($lang !== null) {
            if('form' === 'form' && is_array($lang)) {
                foreach($lang as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['lang'] = $lang;
            }
        }
        // query params
        if (is_array($show)) {
            $show = ObjectSerializer::serializeCollection($show, 'form', true);
        }
        if ($show !== null) {
            $queryParams['show'] = $show;
        }

        // header params
        if ($x_request_id !== null) {
            $headerParams['X-Request-ID'] = ObjectSerializer::toHeaderValue($x_request_id);
        }



        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('apiKey');
        if ($apiKey !== null) {
            $queryParams['apiKey'] = $apiKey;
        }
        // this endpoint requires Bearer (JWT) authentication (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHosts = ["https://browse.search.hereapi.com/v1"];
        if ($this->hostIndex < 0 || $this->hostIndex >= sizeof($operationHosts)) {
            throw new \InvalidArgumentException("Invalid index {$this->hostIndex} when selecting the host. Must be less than ".sizeof($operationHosts));
        }
        $operationHost = $operationHosts[$this->hostIndex];

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation discoverGet
     *
     * Discover
     *
     * This oepration contains host(s) defined in the OpenAP spec. Use 'hostIndex' to select the host.
     * URL: https://discover.search.hereapi.com/v1
     *
     * @param  string $q Enter a free-text query  Examples:  * &#x60;125, Berliner, berlin&#x60;  * &#x60;Beacon, Boston, Hospital&#x60;  * &#x60;Schnurrbart German Pub and Restaurant, Hong Kong&#x60;   _Note: Whitespace, urls, email addresses, or other out-of-scope queries will yield no results. (required)
     * @param  string $at Specify the center of the search context expressed as coordinates  Format: &#x60;{latitude},{longitude}&#x60;  Type: &#x60;{decimal},{decimal}&#x60;  Example: &#x60;-13.163068,-72.545128&#x60; (Machu Picchu Mountain, Peru)  The following constraints apply:   * One of \&quot;at\&quot;, \&quot;in&#x3D;circle\&quot; or \&quot;in&#x3D;bbox\&quot; is required.   * Parameters \&quot;at\&quot;, \&quot;in&#x3D;circle\&quot; and \&quot;in&#x3D;bbox\&quot; are mutually exclusive. Only one of them is allowed. (optional)
     * @param  string $in Search within a geographic area. This is a hard filter. Results will be returned if they are located within the specified area.  A geographic area can be   * a country (or multiple countries), provided as comma-separated [ISO 3166-1 alpha-3](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-3) country codes     The country codes are to be provided in all uppercase.     Format: &#x60;countryCode:{countryCode}[,{countryCode}]*&#x60;     Examples:     * &#x60;countryCode:USA&#x60;     * &#x60;countryCode:CAN,MEX,USA&#x60;    * a circular area, provided as latitude, longitude, and radius (in meters)     Format: &#x60;circle:{latitude},{longitude};r&#x3D;{radius}&#x60;     Type: &#x60;circle:{decimal},{decimal};r&#x3D;{integer}&#x60;     Example: &#x60;circle:52.53,13.38;r&#x3D;10000&#x60;    * a bounding box, provided as _west longitude_, _south latitude_, _east longitude_, _north latitude_     Format: &#x60;bbox:{west longitude},{south latitude},{east longitude},{north latitude}&#x60;     Example: &#x60;bbox:13.08836,52.33812,13.761,52.6755&#x60;   The following constraints apply:   * Parameters \&quot;at\&quot;, \&quot;in&#x3D;circle\&quot; and \&quot;in&#x3D;bbox\&quot; are mutually exclusive. Only one of them is allowed.    * One of \&quot;at\&quot;, \&quot;in&#x3D;circle\&quot; or \&quot;in&#x3D;bbox\&quot; is required.   * The \&quot;in&#x3D;countryCode\&quot; parameter must be accompanied by exactly one of \&quot;at\&quot;, \&quot;in&#x3D;circle\&quot; or \&quot;in&#x3D;bbox\&quot;. (optional)
     * @param  int $limit Maximum number of results to be returned. (optional, default to 20)
     * @param  string $route BETA: Select within a geographic corridor. This is a hard filter. Results will be returned if they are located within the specified area.  A &#x60;route&#x60; is defined by a [Flexible Polyline Encoding](https://github.com/heremaps/flexible-polyline),  followed by an optional width, represented by a sub-parameter \&quot;w\&quot;.   Format: &#x60;{route};w&#x3D;{width}&#x60;  In regular expression syntax, the values of &#x60;route&#x60; look like:  &#x60;[a-zA-Z0-9_-]+(;w&#x3D;\\d+)?&#x60;  \&quot;[a-zA-Z0-9._-]+\&quot; is the encoded flexible polyline.  \&quot;w&#x3D;\\d+\&quot; is the optional width. The width is specified in meters from the center of the path. If no width is provided, the default is 1000 meters.  Type: &#x60;{Flexible Polyline Encoding};w&#x3D;{integer}&#x60;  Examples:  * &#x60;BFoz5xJ67i1B1B7PzIhaxL7Y&#x60;  * &#x60;BFoz5xJ67i1B1B7PzIhaxL7Y;w&#x3D;5000&#x60;  * &#x60;BlD05xgKuy2xCCx9B7vUCl0OhnRC54EqSCzpEl-HCxjD3pBCiGnyGCi2CvwFCsgD3nDC4vB6eC;w&#x3D;2000&#x60;  Note: The last example above can be decoded (using the Python class [here](https://github.com/heremaps/flexible-polyline/tree/master/python) as follows:  &#x60;&#x60;&#x60; &gt;&gt;&gt; import flexpolyline &gt;&gt;&gt; polyline &#x3D; &#39;BlD05xgKuy2xCCx9B7vUCl0OhnRC54EqSCzpEl-HCxjD3pBCiGnyGCi2CvwFCsgD3nDC4vB6eC&#39; &gt;&gt;&gt; flexpolyline.decode(polyline) [(52.51994, 13.38663, 1.0), (52.51009, 13.28169, 2.0), (52.43518, 13.19352, 3.0), (52.41073, 13.19645, 4.0), (52.38871, 13.15578, 5.0), (52.37278, 13.1491, 6.0), (52.37375, 13.11546, 7.0), (52.38752, 13.08722, 8.0), (52.40294, 13.07062, 9.0), (52.41058, 13.07555, 10.0)] &#x60;&#x60;&#x60; (optional)
     * @param  string $lang Select the language to be used for result rendering from a list of [BCP 47](https://en.wikipedia.org/wiki/IETF_language_tag) compliant language codes. (optional)
     * @param  string[] $show Select additional fields to be rendered in the response. Please note that some of the fields involve additional webservice calls and can increase the overall response time.  The value is a comma-separated list of the sections to be enabled. For each section there is a long and a short version of its id.  Description of accepted values:  &#39;phonemes&#39;: Renders phonemes for address and place names into the results. (optional)
     * @param  string $x_request_id Used to correlate requests with their responses within a customer&#39;s application, for logging and error reporting.  Format: Free string, but a valid UUIDv4 is recommended. (optional)
     *
     * @throws \Here\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Here\Model\OpenSearchSearchResponse|\Here\Model\ErrorResponse|\Here\Model\ErrorResponse|\Here\Model\ErrorResponse
     */
    public function discoverGet($q, $at = null, $in = null, $limit = 20, $route = null, $lang = null, $show = null, $x_request_id = null)
    {
        list($response) = $this->discoverGetWithHttpInfo($q, $at, $in, $limit, $route, $lang, $show, $x_request_id);
        return $response;
    }

    /**
     * Operation discoverGetWithHttpInfo
     *
     * Discover
     *
     * This oepration contains host(s) defined in the OpenAP spec. Use 'hostIndex' to select the host.
     * URL: https://discover.search.hereapi.com/v1
     *
     * @param  string $q Enter a free-text query  Examples:  * &#x60;125, Berliner, berlin&#x60;  * &#x60;Beacon, Boston, Hospital&#x60;  * &#x60;Schnurrbart German Pub and Restaurant, Hong Kong&#x60;   _Note: Whitespace, urls, email addresses, or other out-of-scope queries will yield no results. (required)
     * @param  string $at Specify the center of the search context expressed as coordinates  Format: &#x60;{latitude},{longitude}&#x60;  Type: &#x60;{decimal},{decimal}&#x60;  Example: &#x60;-13.163068,-72.545128&#x60; (Machu Picchu Mountain, Peru)  The following constraints apply:   * One of \&quot;at\&quot;, \&quot;in&#x3D;circle\&quot; or \&quot;in&#x3D;bbox\&quot; is required.   * Parameters \&quot;at\&quot;, \&quot;in&#x3D;circle\&quot; and \&quot;in&#x3D;bbox\&quot; are mutually exclusive. Only one of them is allowed. (optional)
     * @param  string $in Search within a geographic area. This is a hard filter. Results will be returned if they are located within the specified area.  A geographic area can be   * a country (or multiple countries), provided as comma-separated [ISO 3166-1 alpha-3](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-3) country codes     The country codes are to be provided in all uppercase.     Format: &#x60;countryCode:{countryCode}[,{countryCode}]*&#x60;     Examples:     * &#x60;countryCode:USA&#x60;     * &#x60;countryCode:CAN,MEX,USA&#x60;    * a circular area, provided as latitude, longitude, and radius (in meters)     Format: &#x60;circle:{latitude},{longitude};r&#x3D;{radius}&#x60;     Type: &#x60;circle:{decimal},{decimal};r&#x3D;{integer}&#x60;     Example: &#x60;circle:52.53,13.38;r&#x3D;10000&#x60;    * a bounding box, provided as _west longitude_, _south latitude_, _east longitude_, _north latitude_     Format: &#x60;bbox:{west longitude},{south latitude},{east longitude},{north latitude}&#x60;     Example: &#x60;bbox:13.08836,52.33812,13.761,52.6755&#x60;   The following constraints apply:   * Parameters \&quot;at\&quot;, \&quot;in&#x3D;circle\&quot; and \&quot;in&#x3D;bbox\&quot; are mutually exclusive. Only one of them is allowed.    * One of \&quot;at\&quot;, \&quot;in&#x3D;circle\&quot; or \&quot;in&#x3D;bbox\&quot; is required.   * The \&quot;in&#x3D;countryCode\&quot; parameter must be accompanied by exactly one of \&quot;at\&quot;, \&quot;in&#x3D;circle\&quot; or \&quot;in&#x3D;bbox\&quot;. (optional)
     * @param  int $limit Maximum number of results to be returned. (optional, default to 20)
     * @param  string $route BETA: Select within a geographic corridor. This is a hard filter. Results will be returned if they are located within the specified area.  A &#x60;route&#x60; is defined by a [Flexible Polyline Encoding](https://github.com/heremaps/flexible-polyline),  followed by an optional width, represented by a sub-parameter \&quot;w\&quot;.   Format: &#x60;{route};w&#x3D;{width}&#x60;  In regular expression syntax, the values of &#x60;route&#x60; look like:  &#x60;[a-zA-Z0-9_-]+(;w&#x3D;\\d+)?&#x60;  \&quot;[a-zA-Z0-9._-]+\&quot; is the encoded flexible polyline.  \&quot;w&#x3D;\\d+\&quot; is the optional width. The width is specified in meters from the center of the path. If no width is provided, the default is 1000 meters.  Type: &#x60;{Flexible Polyline Encoding};w&#x3D;{integer}&#x60;  Examples:  * &#x60;BFoz5xJ67i1B1B7PzIhaxL7Y&#x60;  * &#x60;BFoz5xJ67i1B1B7PzIhaxL7Y;w&#x3D;5000&#x60;  * &#x60;BlD05xgKuy2xCCx9B7vUCl0OhnRC54EqSCzpEl-HCxjD3pBCiGnyGCi2CvwFCsgD3nDC4vB6eC;w&#x3D;2000&#x60;  Note: The last example above can be decoded (using the Python class [here](https://github.com/heremaps/flexible-polyline/tree/master/python) as follows:  &#x60;&#x60;&#x60; &gt;&gt;&gt; import flexpolyline &gt;&gt;&gt; polyline &#x3D; &#39;BlD05xgKuy2xCCx9B7vUCl0OhnRC54EqSCzpEl-HCxjD3pBCiGnyGCi2CvwFCsgD3nDC4vB6eC&#39; &gt;&gt;&gt; flexpolyline.decode(polyline) [(52.51994, 13.38663, 1.0), (52.51009, 13.28169, 2.0), (52.43518, 13.19352, 3.0), (52.41073, 13.19645, 4.0), (52.38871, 13.15578, 5.0), (52.37278, 13.1491, 6.0), (52.37375, 13.11546, 7.0), (52.38752, 13.08722, 8.0), (52.40294, 13.07062, 9.0), (52.41058, 13.07555, 10.0)] &#x60;&#x60;&#x60; (optional)
     * @param  string $lang Select the language to be used for result rendering from a list of [BCP 47](https://en.wikipedia.org/wiki/IETF_language_tag) compliant language codes. (optional)
     * @param  string[] $show Select additional fields to be rendered in the response. Please note that some of the fields involve additional webservice calls and can increase the overall response time.  The value is a comma-separated list of the sections to be enabled. For each section there is a long and a short version of its id.  Description of accepted values:  &#39;phonemes&#39;: Renders phonemes for address and place names into the results. (optional)
     * @param  string $x_request_id Used to correlate requests with their responses within a customer&#39;s application, for logging and error reporting.  Format: Free string, but a valid UUIDv4 is recommended. (optional)
     *
     * @throws \Here\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Here\Model\OpenSearchSearchResponse|\Here\Model\ErrorResponse|\Here\Model\ErrorResponse|\Here\Model\ErrorResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function discoverGetWithHttpInfo($q, $at = null, $in = null, $limit = 20, $route = null, $lang = null, $show = null, $x_request_id = null)
    {
        $request = $this->discoverGetRequest($q, $at, $in, $limit, $route, $lang, $show, $x_request_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\Here\Model\OpenSearchSearchResponse' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Here\Model\OpenSearchSearchResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    if ('\Here\Model\ErrorResponse' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Here\Model\ErrorResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 405:
                    if ('\Here\Model\ErrorResponse' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Here\Model\ErrorResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 503:
                    if ('\Here\Model\ErrorResponse' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Here\Model\ErrorResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Here\Model\OpenSearchSearchResponse';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Here\Model\OpenSearchSearchResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Here\Model\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 405:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Here\Model\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 503:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Here\Model\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation discoverGetAsync
     *
     * Discover
     *
     * This oepration contains host(s) defined in the OpenAP spec. Use 'hostIndex' to select the host.
     * URL: https://discover.search.hereapi.com/v1
     *
     * @param  string $q Enter a free-text query  Examples:  * &#x60;125, Berliner, berlin&#x60;  * &#x60;Beacon, Boston, Hospital&#x60;  * &#x60;Schnurrbart German Pub and Restaurant, Hong Kong&#x60;   _Note: Whitespace, urls, email addresses, or other out-of-scope queries will yield no results. (required)
     * @param  string $at Specify the center of the search context expressed as coordinates  Format: &#x60;{latitude},{longitude}&#x60;  Type: &#x60;{decimal},{decimal}&#x60;  Example: &#x60;-13.163068,-72.545128&#x60; (Machu Picchu Mountain, Peru)  The following constraints apply:   * One of \&quot;at\&quot;, \&quot;in&#x3D;circle\&quot; or \&quot;in&#x3D;bbox\&quot; is required.   * Parameters \&quot;at\&quot;, \&quot;in&#x3D;circle\&quot; and \&quot;in&#x3D;bbox\&quot; are mutually exclusive. Only one of them is allowed. (optional)
     * @param  string $in Search within a geographic area. This is a hard filter. Results will be returned if they are located within the specified area.  A geographic area can be   * a country (or multiple countries), provided as comma-separated [ISO 3166-1 alpha-3](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-3) country codes     The country codes are to be provided in all uppercase.     Format: &#x60;countryCode:{countryCode}[,{countryCode}]*&#x60;     Examples:     * &#x60;countryCode:USA&#x60;     * &#x60;countryCode:CAN,MEX,USA&#x60;    * a circular area, provided as latitude, longitude, and radius (in meters)     Format: &#x60;circle:{latitude},{longitude};r&#x3D;{radius}&#x60;     Type: &#x60;circle:{decimal},{decimal};r&#x3D;{integer}&#x60;     Example: &#x60;circle:52.53,13.38;r&#x3D;10000&#x60;    * a bounding box, provided as _west longitude_, _south latitude_, _east longitude_, _north latitude_     Format: &#x60;bbox:{west longitude},{south latitude},{east longitude},{north latitude}&#x60;     Example: &#x60;bbox:13.08836,52.33812,13.761,52.6755&#x60;   The following constraints apply:   * Parameters \&quot;at\&quot;, \&quot;in&#x3D;circle\&quot; and \&quot;in&#x3D;bbox\&quot; are mutually exclusive. Only one of them is allowed.    * One of \&quot;at\&quot;, \&quot;in&#x3D;circle\&quot; or \&quot;in&#x3D;bbox\&quot; is required.   * The \&quot;in&#x3D;countryCode\&quot; parameter must be accompanied by exactly one of \&quot;at\&quot;, \&quot;in&#x3D;circle\&quot; or \&quot;in&#x3D;bbox\&quot;. (optional)
     * @param  int $limit Maximum number of results to be returned. (optional, default to 20)
     * @param  string $route BETA: Select within a geographic corridor. This is a hard filter. Results will be returned if they are located within the specified area.  A &#x60;route&#x60; is defined by a [Flexible Polyline Encoding](https://github.com/heremaps/flexible-polyline),  followed by an optional width, represented by a sub-parameter \&quot;w\&quot;.   Format: &#x60;{route};w&#x3D;{width}&#x60;  In regular expression syntax, the values of &#x60;route&#x60; look like:  &#x60;[a-zA-Z0-9_-]+(;w&#x3D;\\d+)?&#x60;  \&quot;[a-zA-Z0-9._-]+\&quot; is the encoded flexible polyline.  \&quot;w&#x3D;\\d+\&quot; is the optional width. The width is specified in meters from the center of the path. If no width is provided, the default is 1000 meters.  Type: &#x60;{Flexible Polyline Encoding};w&#x3D;{integer}&#x60;  Examples:  * &#x60;BFoz5xJ67i1B1B7PzIhaxL7Y&#x60;  * &#x60;BFoz5xJ67i1B1B7PzIhaxL7Y;w&#x3D;5000&#x60;  * &#x60;BlD05xgKuy2xCCx9B7vUCl0OhnRC54EqSCzpEl-HCxjD3pBCiGnyGCi2CvwFCsgD3nDC4vB6eC;w&#x3D;2000&#x60;  Note: The last example above can be decoded (using the Python class [here](https://github.com/heremaps/flexible-polyline/tree/master/python) as follows:  &#x60;&#x60;&#x60; &gt;&gt;&gt; import flexpolyline &gt;&gt;&gt; polyline &#x3D; &#39;BlD05xgKuy2xCCx9B7vUCl0OhnRC54EqSCzpEl-HCxjD3pBCiGnyGCi2CvwFCsgD3nDC4vB6eC&#39; &gt;&gt;&gt; flexpolyline.decode(polyline) [(52.51994, 13.38663, 1.0), (52.51009, 13.28169, 2.0), (52.43518, 13.19352, 3.0), (52.41073, 13.19645, 4.0), (52.38871, 13.15578, 5.0), (52.37278, 13.1491, 6.0), (52.37375, 13.11546, 7.0), (52.38752, 13.08722, 8.0), (52.40294, 13.07062, 9.0), (52.41058, 13.07555, 10.0)] &#x60;&#x60;&#x60; (optional)
     * @param  string $lang Select the language to be used for result rendering from a list of [BCP 47](https://en.wikipedia.org/wiki/IETF_language_tag) compliant language codes. (optional)
     * @param  string[] $show Select additional fields to be rendered in the response. Please note that some of the fields involve additional webservice calls and can increase the overall response time.  The value is a comma-separated list of the sections to be enabled. For each section there is a long and a short version of its id.  Description of accepted values:  &#39;phonemes&#39;: Renders phonemes for address and place names into the results. (optional)
     * @param  string $x_request_id Used to correlate requests with their responses within a customer&#39;s application, for logging and error reporting.  Format: Free string, but a valid UUIDv4 is recommended. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function discoverGetAsync($q, $at = null, $in = null, $limit = 20, $route = null, $lang = null, $show = null, $x_request_id = null)
    {
        return $this->discoverGetAsyncWithHttpInfo($q, $at, $in, $limit, $route, $lang, $show, $x_request_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation discoverGetAsyncWithHttpInfo
     *
     * Discover
     *
     * This oepration contains host(s) defined in the OpenAP spec. Use 'hostIndex' to select the host.
     * URL: https://discover.search.hereapi.com/v1
     *
     * @param  string $q Enter a free-text query  Examples:  * &#x60;125, Berliner, berlin&#x60;  * &#x60;Beacon, Boston, Hospital&#x60;  * &#x60;Schnurrbart German Pub and Restaurant, Hong Kong&#x60;   _Note: Whitespace, urls, email addresses, or other out-of-scope queries will yield no results. (required)
     * @param  string $at Specify the center of the search context expressed as coordinates  Format: &#x60;{latitude},{longitude}&#x60;  Type: &#x60;{decimal},{decimal}&#x60;  Example: &#x60;-13.163068,-72.545128&#x60; (Machu Picchu Mountain, Peru)  The following constraints apply:   * One of \&quot;at\&quot;, \&quot;in&#x3D;circle\&quot; or \&quot;in&#x3D;bbox\&quot; is required.   * Parameters \&quot;at\&quot;, \&quot;in&#x3D;circle\&quot; and \&quot;in&#x3D;bbox\&quot; are mutually exclusive. Only one of them is allowed. (optional)
     * @param  string $in Search within a geographic area. This is a hard filter. Results will be returned if they are located within the specified area.  A geographic area can be   * a country (or multiple countries), provided as comma-separated [ISO 3166-1 alpha-3](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-3) country codes     The country codes are to be provided in all uppercase.     Format: &#x60;countryCode:{countryCode}[,{countryCode}]*&#x60;     Examples:     * &#x60;countryCode:USA&#x60;     * &#x60;countryCode:CAN,MEX,USA&#x60;    * a circular area, provided as latitude, longitude, and radius (in meters)     Format: &#x60;circle:{latitude},{longitude};r&#x3D;{radius}&#x60;     Type: &#x60;circle:{decimal},{decimal};r&#x3D;{integer}&#x60;     Example: &#x60;circle:52.53,13.38;r&#x3D;10000&#x60;    * a bounding box, provided as _west longitude_, _south latitude_, _east longitude_, _north latitude_     Format: &#x60;bbox:{west longitude},{south latitude},{east longitude},{north latitude}&#x60;     Example: &#x60;bbox:13.08836,52.33812,13.761,52.6755&#x60;   The following constraints apply:   * Parameters \&quot;at\&quot;, \&quot;in&#x3D;circle\&quot; and \&quot;in&#x3D;bbox\&quot; are mutually exclusive. Only one of them is allowed.    * One of \&quot;at\&quot;, \&quot;in&#x3D;circle\&quot; or \&quot;in&#x3D;bbox\&quot; is required.   * The \&quot;in&#x3D;countryCode\&quot; parameter must be accompanied by exactly one of \&quot;at\&quot;, \&quot;in&#x3D;circle\&quot; or \&quot;in&#x3D;bbox\&quot;. (optional)
     * @param  int $limit Maximum number of results to be returned. (optional, default to 20)
     * @param  string $route BETA: Select within a geographic corridor. This is a hard filter. Results will be returned if they are located within the specified area.  A &#x60;route&#x60; is defined by a [Flexible Polyline Encoding](https://github.com/heremaps/flexible-polyline),  followed by an optional width, represented by a sub-parameter \&quot;w\&quot;.   Format: &#x60;{route};w&#x3D;{width}&#x60;  In regular expression syntax, the values of &#x60;route&#x60; look like:  &#x60;[a-zA-Z0-9_-]+(;w&#x3D;\\d+)?&#x60;  \&quot;[a-zA-Z0-9._-]+\&quot; is the encoded flexible polyline.  \&quot;w&#x3D;\\d+\&quot; is the optional width. The width is specified in meters from the center of the path. If no width is provided, the default is 1000 meters.  Type: &#x60;{Flexible Polyline Encoding};w&#x3D;{integer}&#x60;  Examples:  * &#x60;BFoz5xJ67i1B1B7PzIhaxL7Y&#x60;  * &#x60;BFoz5xJ67i1B1B7PzIhaxL7Y;w&#x3D;5000&#x60;  * &#x60;BlD05xgKuy2xCCx9B7vUCl0OhnRC54EqSCzpEl-HCxjD3pBCiGnyGCi2CvwFCsgD3nDC4vB6eC;w&#x3D;2000&#x60;  Note: The last example above can be decoded (using the Python class [here](https://github.com/heremaps/flexible-polyline/tree/master/python) as follows:  &#x60;&#x60;&#x60; &gt;&gt;&gt; import flexpolyline &gt;&gt;&gt; polyline &#x3D; &#39;BlD05xgKuy2xCCx9B7vUCl0OhnRC54EqSCzpEl-HCxjD3pBCiGnyGCi2CvwFCsgD3nDC4vB6eC&#39; &gt;&gt;&gt; flexpolyline.decode(polyline) [(52.51994, 13.38663, 1.0), (52.51009, 13.28169, 2.0), (52.43518, 13.19352, 3.0), (52.41073, 13.19645, 4.0), (52.38871, 13.15578, 5.0), (52.37278, 13.1491, 6.0), (52.37375, 13.11546, 7.0), (52.38752, 13.08722, 8.0), (52.40294, 13.07062, 9.0), (52.41058, 13.07555, 10.0)] &#x60;&#x60;&#x60; (optional)
     * @param  string $lang Select the language to be used for result rendering from a list of [BCP 47](https://en.wikipedia.org/wiki/IETF_language_tag) compliant language codes. (optional)
     * @param  string[] $show Select additional fields to be rendered in the response. Please note that some of the fields involve additional webservice calls and can increase the overall response time.  The value is a comma-separated list of the sections to be enabled. For each section there is a long and a short version of its id.  Description of accepted values:  &#39;phonemes&#39;: Renders phonemes for address and place names into the results. (optional)
     * @param  string $x_request_id Used to correlate requests with their responses within a customer&#39;s application, for logging and error reporting.  Format: Free string, but a valid UUIDv4 is recommended. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function discoverGetAsyncWithHttpInfo($q, $at = null, $in = null, $limit = 20, $route = null, $lang = null, $show = null, $x_request_id = null)
    {
        $returnType = '\Here\Model\OpenSearchSearchResponse';
        $request = $this->discoverGetRequest($q, $at, $in, $limit, $route, $lang, $show, $x_request_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'discoverGet'
     *
     * This oepration contains host(s) defined in the OpenAP spec. Use 'hostIndex' to select the host.
     * URL: https://discover.search.hereapi.com/v1
     *
     * @param  string $q Enter a free-text query  Examples:  * &#x60;125, Berliner, berlin&#x60;  * &#x60;Beacon, Boston, Hospital&#x60;  * &#x60;Schnurrbart German Pub and Restaurant, Hong Kong&#x60;   _Note: Whitespace, urls, email addresses, or other out-of-scope queries will yield no results. (required)
     * @param  string $at Specify the center of the search context expressed as coordinates  Format: &#x60;{latitude},{longitude}&#x60;  Type: &#x60;{decimal},{decimal}&#x60;  Example: &#x60;-13.163068,-72.545128&#x60; (Machu Picchu Mountain, Peru)  The following constraints apply:   * One of \&quot;at\&quot;, \&quot;in&#x3D;circle\&quot; or \&quot;in&#x3D;bbox\&quot; is required.   * Parameters \&quot;at\&quot;, \&quot;in&#x3D;circle\&quot; and \&quot;in&#x3D;bbox\&quot; are mutually exclusive. Only one of them is allowed. (optional)
     * @param  string $in Search within a geographic area. This is a hard filter. Results will be returned if they are located within the specified area.  A geographic area can be   * a country (or multiple countries), provided as comma-separated [ISO 3166-1 alpha-3](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-3) country codes     The country codes are to be provided in all uppercase.     Format: &#x60;countryCode:{countryCode}[,{countryCode}]*&#x60;     Examples:     * &#x60;countryCode:USA&#x60;     * &#x60;countryCode:CAN,MEX,USA&#x60;    * a circular area, provided as latitude, longitude, and radius (in meters)     Format: &#x60;circle:{latitude},{longitude};r&#x3D;{radius}&#x60;     Type: &#x60;circle:{decimal},{decimal};r&#x3D;{integer}&#x60;     Example: &#x60;circle:52.53,13.38;r&#x3D;10000&#x60;    * a bounding box, provided as _west longitude_, _south latitude_, _east longitude_, _north latitude_     Format: &#x60;bbox:{west longitude},{south latitude},{east longitude},{north latitude}&#x60;     Example: &#x60;bbox:13.08836,52.33812,13.761,52.6755&#x60;   The following constraints apply:   * Parameters \&quot;at\&quot;, \&quot;in&#x3D;circle\&quot; and \&quot;in&#x3D;bbox\&quot; are mutually exclusive. Only one of them is allowed.    * One of \&quot;at\&quot;, \&quot;in&#x3D;circle\&quot; or \&quot;in&#x3D;bbox\&quot; is required.   * The \&quot;in&#x3D;countryCode\&quot; parameter must be accompanied by exactly one of \&quot;at\&quot;, \&quot;in&#x3D;circle\&quot; or \&quot;in&#x3D;bbox\&quot;. (optional)
     * @param  int $limit Maximum number of results to be returned. (optional, default to 20)
     * @param  string $route BETA: Select within a geographic corridor. This is a hard filter. Results will be returned if they are located within the specified area.  A &#x60;route&#x60; is defined by a [Flexible Polyline Encoding](https://github.com/heremaps/flexible-polyline),  followed by an optional width, represented by a sub-parameter \&quot;w\&quot;.   Format: &#x60;{route};w&#x3D;{width}&#x60;  In regular expression syntax, the values of &#x60;route&#x60; look like:  &#x60;[a-zA-Z0-9_-]+(;w&#x3D;\\d+)?&#x60;  \&quot;[a-zA-Z0-9._-]+\&quot; is the encoded flexible polyline.  \&quot;w&#x3D;\\d+\&quot; is the optional width. The width is specified in meters from the center of the path. If no width is provided, the default is 1000 meters.  Type: &#x60;{Flexible Polyline Encoding};w&#x3D;{integer}&#x60;  Examples:  * &#x60;BFoz5xJ67i1B1B7PzIhaxL7Y&#x60;  * &#x60;BFoz5xJ67i1B1B7PzIhaxL7Y;w&#x3D;5000&#x60;  * &#x60;BlD05xgKuy2xCCx9B7vUCl0OhnRC54EqSCzpEl-HCxjD3pBCiGnyGCi2CvwFCsgD3nDC4vB6eC;w&#x3D;2000&#x60;  Note: The last example above can be decoded (using the Python class [here](https://github.com/heremaps/flexible-polyline/tree/master/python) as follows:  &#x60;&#x60;&#x60; &gt;&gt;&gt; import flexpolyline &gt;&gt;&gt; polyline &#x3D; &#39;BlD05xgKuy2xCCx9B7vUCl0OhnRC54EqSCzpEl-HCxjD3pBCiGnyGCi2CvwFCsgD3nDC4vB6eC&#39; &gt;&gt;&gt; flexpolyline.decode(polyline) [(52.51994, 13.38663, 1.0), (52.51009, 13.28169, 2.0), (52.43518, 13.19352, 3.0), (52.41073, 13.19645, 4.0), (52.38871, 13.15578, 5.0), (52.37278, 13.1491, 6.0), (52.37375, 13.11546, 7.0), (52.38752, 13.08722, 8.0), (52.40294, 13.07062, 9.0), (52.41058, 13.07555, 10.0)] &#x60;&#x60;&#x60; (optional)
     * @param  string $lang Select the language to be used for result rendering from a list of [BCP 47](https://en.wikipedia.org/wiki/IETF_language_tag) compliant language codes. (optional)
     * @param  string[] $show Select additional fields to be rendered in the response. Please note that some of the fields involve additional webservice calls and can increase the overall response time.  The value is a comma-separated list of the sections to be enabled. For each section there is a long and a short version of its id.  Description of accepted values:  &#39;phonemes&#39;: Renders phonemes for address and place names into the results. (optional)
     * @param  string $x_request_id Used to correlate requests with their responses within a customer&#39;s application, for logging and error reporting.  Format: Free string, but a valid UUIDv4 is recommended. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function discoverGetRequest($q, $at = null, $in = null, $limit = 20, $route = null, $lang = null, $show = null, $x_request_id = null)
    {
        // verify the required parameter 'q' is set
        if ($q === null || (is_array($q) && count($q) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $q when calling discoverGet'
            );
        }
        if ($limit !== null && $limit > 100) {
            throw new \InvalidArgumentException('invalid value for "$limit" when calling DefaultApi.discoverGet, must be smaller than or equal to 100.');
        }
        if ($limit !== null && $limit < 1) {
            throw new \InvalidArgumentException('invalid value for "$limit" when calling DefaultApi.discoverGet, must be bigger than or equal to 1.');
        }


        $resourcePath = '/discover';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($q !== null) {
            if('form' === 'form' && is_array($q)) {
                foreach($q as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['q'] = $q;
            }
        }
        // query params
        if ($at !== null) {
            if('form' === 'form' && is_array($at)) {
                foreach($at as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['at'] = $at;
            }
        }
        // query params
        if ($in !== null) {
            if('form' === 'form' && is_array($in)) {
                foreach($in as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['in'] = $in;
            }
        }
        // query params
        if ($limit !== null) {
            if('form' === 'form' && is_array($limit)) {
                foreach($limit as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['limit'] = $limit;
            }
        }
        // query params
        if ($route !== null) {
            if('form' === 'form' && is_array($route)) {
                foreach($route as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['route'] = $route;
            }
        }
        // query params
        if ($lang !== null) {
            if('form' === 'form' && is_array($lang)) {
                foreach($lang as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['lang'] = $lang;
            }
        }
        // query params
        if (is_array($show)) {
            $show = ObjectSerializer::serializeCollection($show, 'form', true);
        }
        if ($show !== null) {
            $queryParams['show'] = $show;
        }

        // header params
        if ($x_request_id !== null) {
            $headerParams['X-Request-ID'] = ObjectSerializer::toHeaderValue($x_request_id);
        }



        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('apiKey');
        if ($apiKey !== null) {
            $queryParams['apiKey'] = $apiKey;
        }
        // this endpoint requires Bearer (JWT) authentication (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHosts = ["https://discover.search.hereapi.com/v1"];
        if ($this->hostIndex < 0 || $this->hostIndex >= sizeof($operationHosts)) {
            throw new \InvalidArgumentException("Invalid index {$this->hostIndex} when selecting the host. Must be less than ".sizeof($operationHosts));
        }
        $operationHost = $operationHosts[$this->hostIndex];

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation geocodeGet
     *
     * Geocode
     *
     * This oepration contains host(s) defined in the OpenAP spec. Use 'hostIndex' to select the host.
     * URL: https://geocode.search.hereapi.com/v1
     *
     * @param  string $at Specify the center of the search context expressed as coordinates.  Format: &#x60;{latitude},{longitude}&#x60;  Type: &#x60;{decimal},{decimal}&#x60;  Example: &#x60;-13.163068,-72.545128&#x60; (Machu Picchu Mountain, Peru) (optional)
     * @param  string $in Search within a geographic area. This is a hard filter. Results will be returned if they are located within the specified area.  A geographic area can be   * a country (or multiple countries), provided as comma-separated [ISO 3166-1 alpha-3](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-3) country codes     The country codes are to be provided in all uppercase.     Format: &#x60;countryCode:{countryCode}[,{countryCode}]*&#x60;     Examples:     * &#x60;countryCode:USA&#x60;     * &#x60;countryCode:CAN,MEX,USA&#x60; (optional)
     * @param  int $limit Maximum number of results to be returned. (optional, default to 20)
     * @param  string $q Enter a free-text query  Examples:  * &#x60;125, Berliner, berlin&#x60;  * &#x60;Beacon, Boston, Hospital&#x60;  * &#x60;Schnurrbart German Pub and Restaurant, Hong Kong&#x60;  _Note: Either &#x60;q&#x60; or &#x60;qq&#x60;-parameter is required on this endpoint. Both parameters can be provided in the same request._ (optional)
     * @param  string $qq Enter a qualified query. A qualified query is similar to a free-text query, but in a structured manner.  It can take multiple _sub-parameters_, separated by semicolon, allowing to specify different aspects of a query.  Currently supported _sub-parameters_ are &#x60;country&#x60;, &#x60;state&#x60;, &#x60;county&#x60;, &#x60;city&#x60;, &#x60;district&#x60;, &#x60;street&#x60;,  &#x60;houseNumber&#x60;, and &#x60;postalCode&#x60;.  Format: &#x60;{sub-parameter}&#x3D;{string}[;{sub-parameter}&#x3D;{string}]*&#x60;  Examples:  * &#x60;city&#x3D;Berlin;country&#x3D;Germany;street&#x3D;Friedrichstr;houseNumber&#x3D;20&#x60;  * &#x60;city&#x3D;Berlin;country&#x3D;Germany&#x60;  * &#x60;postalCode&#x3D;10969&#x60;  _Note: Either &#x60;q&#x60; or &#x60;qq&#x60;-parameter is required on this endpoint. Both parameters can be provided in the same request._ (optional)
     * @param  string $lang Select the language to be used for result rendering from a list of [BCP 47](https://en.wikipedia.org/wiki/IETF_language_tag) compliant language codes. (optional)
     * @param  string[] $show Select additional fields to be rendered in the response. Please note that some of the fields involve additional webservice calls and can increase the overall response time.  The value is a comma-separated list of the sections to be enabled. For each section there is a long and a short version of its id.  Description of accepted values:  BETA: &#39;parsing&#39; (optional)
     * @param  string $x_request_id Used to correlate requests with their responses within a customer&#39;s application, for logging and error reporting.  Format: Free string, but a valid UUIDv4 is recommended. (optional)
     *
     * @throws \Here\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Here\Model\OpenSearchGeocodeResponse|\Here\Model\ErrorResponse|\Here\Model\ErrorResponse|\Here\Model\ErrorResponse
     */
    public function geocodeGet($at = null, $in = null, $limit = 20, $q = null, $qq = null, $lang = null, $show = null, $x_request_id = null)
    {
        list($response) = $this->geocodeGetWithHttpInfo($at, $in, $limit, $q, $qq, $lang, $show, $x_request_id);
        return $response;
    }

    /**
     * Operation geocodeGetWithHttpInfo
     *
     * Geocode
     *
     * This oepration contains host(s) defined in the OpenAP spec. Use 'hostIndex' to select the host.
     * URL: https://geocode.search.hereapi.com/v1
     *
     * @param  string $at Specify the center of the search context expressed as coordinates.  Format: &#x60;{latitude},{longitude}&#x60;  Type: &#x60;{decimal},{decimal}&#x60;  Example: &#x60;-13.163068,-72.545128&#x60; (Machu Picchu Mountain, Peru) (optional)
     * @param  string $in Search within a geographic area. This is a hard filter. Results will be returned if they are located within the specified area.  A geographic area can be   * a country (or multiple countries), provided as comma-separated [ISO 3166-1 alpha-3](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-3) country codes     The country codes are to be provided in all uppercase.     Format: &#x60;countryCode:{countryCode}[,{countryCode}]*&#x60;     Examples:     * &#x60;countryCode:USA&#x60;     * &#x60;countryCode:CAN,MEX,USA&#x60; (optional)
     * @param  int $limit Maximum number of results to be returned. (optional, default to 20)
     * @param  string $q Enter a free-text query  Examples:  * &#x60;125, Berliner, berlin&#x60;  * &#x60;Beacon, Boston, Hospital&#x60;  * &#x60;Schnurrbart German Pub and Restaurant, Hong Kong&#x60;  _Note: Either &#x60;q&#x60; or &#x60;qq&#x60;-parameter is required on this endpoint. Both parameters can be provided in the same request._ (optional)
     * @param  string $qq Enter a qualified query. A qualified query is similar to a free-text query, but in a structured manner.  It can take multiple _sub-parameters_, separated by semicolon, allowing to specify different aspects of a query.  Currently supported _sub-parameters_ are &#x60;country&#x60;, &#x60;state&#x60;, &#x60;county&#x60;, &#x60;city&#x60;, &#x60;district&#x60;, &#x60;street&#x60;,  &#x60;houseNumber&#x60;, and &#x60;postalCode&#x60;.  Format: &#x60;{sub-parameter}&#x3D;{string}[;{sub-parameter}&#x3D;{string}]*&#x60;  Examples:  * &#x60;city&#x3D;Berlin;country&#x3D;Germany;street&#x3D;Friedrichstr;houseNumber&#x3D;20&#x60;  * &#x60;city&#x3D;Berlin;country&#x3D;Germany&#x60;  * &#x60;postalCode&#x3D;10969&#x60;  _Note: Either &#x60;q&#x60; or &#x60;qq&#x60;-parameter is required on this endpoint. Both parameters can be provided in the same request._ (optional)
     * @param  string $lang Select the language to be used for result rendering from a list of [BCP 47](https://en.wikipedia.org/wiki/IETF_language_tag) compliant language codes. (optional)
     * @param  string[] $show Select additional fields to be rendered in the response. Please note that some of the fields involve additional webservice calls and can increase the overall response time.  The value is a comma-separated list of the sections to be enabled. For each section there is a long and a short version of its id.  Description of accepted values:  BETA: &#39;parsing&#39; (optional)
     * @param  string $x_request_id Used to correlate requests with their responses within a customer&#39;s application, for logging and error reporting.  Format: Free string, but a valid UUIDv4 is recommended. (optional)
     *
     * @throws \Here\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Here\Model\OpenSearchGeocodeResponse|\Here\Model\ErrorResponse|\Here\Model\ErrorResponse|\Here\Model\ErrorResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function geocodeGetWithHttpInfo($at = null, $in = null, $limit = 20, $q = null, $qq = null, $lang = null, $show = null, $x_request_id = null)
    {
        $request = $this->geocodeGetRequest($at, $in, $limit, $q, $qq, $lang, $show, $x_request_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\Here\Model\OpenSearchGeocodeResponse' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Here\Model\OpenSearchGeocodeResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    if ('\Here\Model\ErrorResponse' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Here\Model\ErrorResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 405:
                    if ('\Here\Model\ErrorResponse' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Here\Model\ErrorResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 503:
                    if ('\Here\Model\ErrorResponse' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Here\Model\ErrorResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Here\Model\OpenSearchGeocodeResponse';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Here\Model\OpenSearchGeocodeResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Here\Model\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 405:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Here\Model\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 503:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Here\Model\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation geocodeGetAsync
     *
     * Geocode
     *
     * This oepration contains host(s) defined in the OpenAP spec. Use 'hostIndex' to select the host.
     * URL: https://geocode.search.hereapi.com/v1
     *
     * @param  string $at Specify the center of the search context expressed as coordinates.  Format: &#x60;{latitude},{longitude}&#x60;  Type: &#x60;{decimal},{decimal}&#x60;  Example: &#x60;-13.163068,-72.545128&#x60; (Machu Picchu Mountain, Peru) (optional)
     * @param  string $in Search within a geographic area. This is a hard filter. Results will be returned if they are located within the specified area.  A geographic area can be   * a country (or multiple countries), provided as comma-separated [ISO 3166-1 alpha-3](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-3) country codes     The country codes are to be provided in all uppercase.     Format: &#x60;countryCode:{countryCode}[,{countryCode}]*&#x60;     Examples:     * &#x60;countryCode:USA&#x60;     * &#x60;countryCode:CAN,MEX,USA&#x60; (optional)
     * @param  int $limit Maximum number of results to be returned. (optional, default to 20)
     * @param  string $q Enter a free-text query  Examples:  * &#x60;125, Berliner, berlin&#x60;  * &#x60;Beacon, Boston, Hospital&#x60;  * &#x60;Schnurrbart German Pub and Restaurant, Hong Kong&#x60;  _Note: Either &#x60;q&#x60; or &#x60;qq&#x60;-parameter is required on this endpoint. Both parameters can be provided in the same request._ (optional)
     * @param  string $qq Enter a qualified query. A qualified query is similar to a free-text query, but in a structured manner.  It can take multiple _sub-parameters_, separated by semicolon, allowing to specify different aspects of a query.  Currently supported _sub-parameters_ are &#x60;country&#x60;, &#x60;state&#x60;, &#x60;county&#x60;, &#x60;city&#x60;, &#x60;district&#x60;, &#x60;street&#x60;,  &#x60;houseNumber&#x60;, and &#x60;postalCode&#x60;.  Format: &#x60;{sub-parameter}&#x3D;{string}[;{sub-parameter}&#x3D;{string}]*&#x60;  Examples:  * &#x60;city&#x3D;Berlin;country&#x3D;Germany;street&#x3D;Friedrichstr;houseNumber&#x3D;20&#x60;  * &#x60;city&#x3D;Berlin;country&#x3D;Germany&#x60;  * &#x60;postalCode&#x3D;10969&#x60;  _Note: Either &#x60;q&#x60; or &#x60;qq&#x60;-parameter is required on this endpoint. Both parameters can be provided in the same request._ (optional)
     * @param  string $lang Select the language to be used for result rendering from a list of [BCP 47](https://en.wikipedia.org/wiki/IETF_language_tag) compliant language codes. (optional)
     * @param  string[] $show Select additional fields to be rendered in the response. Please note that some of the fields involve additional webservice calls and can increase the overall response time.  The value is a comma-separated list of the sections to be enabled. For each section there is a long and a short version of its id.  Description of accepted values:  BETA: &#39;parsing&#39; (optional)
     * @param  string $x_request_id Used to correlate requests with their responses within a customer&#39;s application, for logging and error reporting.  Format: Free string, but a valid UUIDv4 is recommended. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function geocodeGetAsync($at = null, $in = null, $limit = 20, $q = null, $qq = null, $lang = null, $show = null, $x_request_id = null)
    {
        return $this->geocodeGetAsyncWithHttpInfo($at, $in, $limit, $q, $qq, $lang, $show, $x_request_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation geocodeGetAsyncWithHttpInfo
     *
     * Geocode
     *
     * This oepration contains host(s) defined in the OpenAP spec. Use 'hostIndex' to select the host.
     * URL: https://geocode.search.hereapi.com/v1
     *
     * @param  string $at Specify the center of the search context expressed as coordinates.  Format: &#x60;{latitude},{longitude}&#x60;  Type: &#x60;{decimal},{decimal}&#x60;  Example: &#x60;-13.163068,-72.545128&#x60; (Machu Picchu Mountain, Peru) (optional)
     * @param  string $in Search within a geographic area. This is a hard filter. Results will be returned if they are located within the specified area.  A geographic area can be   * a country (or multiple countries), provided as comma-separated [ISO 3166-1 alpha-3](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-3) country codes     The country codes are to be provided in all uppercase.     Format: &#x60;countryCode:{countryCode}[,{countryCode}]*&#x60;     Examples:     * &#x60;countryCode:USA&#x60;     * &#x60;countryCode:CAN,MEX,USA&#x60; (optional)
     * @param  int $limit Maximum number of results to be returned. (optional, default to 20)
     * @param  string $q Enter a free-text query  Examples:  * &#x60;125, Berliner, berlin&#x60;  * &#x60;Beacon, Boston, Hospital&#x60;  * &#x60;Schnurrbart German Pub and Restaurant, Hong Kong&#x60;  _Note: Either &#x60;q&#x60; or &#x60;qq&#x60;-parameter is required on this endpoint. Both parameters can be provided in the same request._ (optional)
     * @param  string $qq Enter a qualified query. A qualified query is similar to a free-text query, but in a structured manner.  It can take multiple _sub-parameters_, separated by semicolon, allowing to specify different aspects of a query.  Currently supported _sub-parameters_ are &#x60;country&#x60;, &#x60;state&#x60;, &#x60;county&#x60;, &#x60;city&#x60;, &#x60;district&#x60;, &#x60;street&#x60;,  &#x60;houseNumber&#x60;, and &#x60;postalCode&#x60;.  Format: &#x60;{sub-parameter}&#x3D;{string}[;{sub-parameter}&#x3D;{string}]*&#x60;  Examples:  * &#x60;city&#x3D;Berlin;country&#x3D;Germany;street&#x3D;Friedrichstr;houseNumber&#x3D;20&#x60;  * &#x60;city&#x3D;Berlin;country&#x3D;Germany&#x60;  * &#x60;postalCode&#x3D;10969&#x60;  _Note: Either &#x60;q&#x60; or &#x60;qq&#x60;-parameter is required on this endpoint. Both parameters can be provided in the same request._ (optional)
     * @param  string $lang Select the language to be used for result rendering from a list of [BCP 47](https://en.wikipedia.org/wiki/IETF_language_tag) compliant language codes. (optional)
     * @param  string[] $show Select additional fields to be rendered in the response. Please note that some of the fields involve additional webservice calls and can increase the overall response time.  The value is a comma-separated list of the sections to be enabled. For each section there is a long and a short version of its id.  Description of accepted values:  BETA: &#39;parsing&#39; (optional)
     * @param  string $x_request_id Used to correlate requests with their responses within a customer&#39;s application, for logging and error reporting.  Format: Free string, but a valid UUIDv4 is recommended. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function geocodeGetAsyncWithHttpInfo($at = null, $in = null, $limit = 20, $q = null, $qq = null, $lang = null, $show = null, $x_request_id = null)
    {
        $returnType = '\Here\Model\OpenSearchGeocodeResponse';
        $request = $this->geocodeGetRequest($at, $in, $limit, $q, $qq, $lang, $show, $x_request_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'geocodeGet'
     *
     * This oepration contains host(s) defined in the OpenAP spec. Use 'hostIndex' to select the host.
     * URL: https://geocode.search.hereapi.com/v1
     *
     * @param  string $at Specify the center of the search context expressed as coordinates.  Format: &#x60;{latitude},{longitude}&#x60;  Type: &#x60;{decimal},{decimal}&#x60;  Example: &#x60;-13.163068,-72.545128&#x60; (Machu Picchu Mountain, Peru) (optional)
     * @param  string $in Search within a geographic area. This is a hard filter. Results will be returned if they are located within the specified area.  A geographic area can be   * a country (or multiple countries), provided as comma-separated [ISO 3166-1 alpha-3](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-3) country codes     The country codes are to be provided in all uppercase.     Format: &#x60;countryCode:{countryCode}[,{countryCode}]*&#x60;     Examples:     * &#x60;countryCode:USA&#x60;     * &#x60;countryCode:CAN,MEX,USA&#x60; (optional)
     * @param  int $limit Maximum number of results to be returned. (optional, default to 20)
     * @param  string $q Enter a free-text query  Examples:  * &#x60;125, Berliner, berlin&#x60;  * &#x60;Beacon, Boston, Hospital&#x60;  * &#x60;Schnurrbart German Pub and Restaurant, Hong Kong&#x60;  _Note: Either &#x60;q&#x60; or &#x60;qq&#x60;-parameter is required on this endpoint. Both parameters can be provided in the same request._ (optional)
     * @param  string $qq Enter a qualified query. A qualified query is similar to a free-text query, but in a structured manner.  It can take multiple _sub-parameters_, separated by semicolon, allowing to specify different aspects of a query.  Currently supported _sub-parameters_ are &#x60;country&#x60;, &#x60;state&#x60;, &#x60;county&#x60;, &#x60;city&#x60;, &#x60;district&#x60;, &#x60;street&#x60;,  &#x60;houseNumber&#x60;, and &#x60;postalCode&#x60;.  Format: &#x60;{sub-parameter}&#x3D;{string}[;{sub-parameter}&#x3D;{string}]*&#x60;  Examples:  * &#x60;city&#x3D;Berlin;country&#x3D;Germany;street&#x3D;Friedrichstr;houseNumber&#x3D;20&#x60;  * &#x60;city&#x3D;Berlin;country&#x3D;Germany&#x60;  * &#x60;postalCode&#x3D;10969&#x60;  _Note: Either &#x60;q&#x60; or &#x60;qq&#x60;-parameter is required on this endpoint. Both parameters can be provided in the same request._ (optional)
     * @param  string $lang Select the language to be used for result rendering from a list of [BCP 47](https://en.wikipedia.org/wiki/IETF_language_tag) compliant language codes. (optional)
     * @param  string[] $show Select additional fields to be rendered in the response. Please note that some of the fields involve additional webservice calls and can increase the overall response time.  The value is a comma-separated list of the sections to be enabled. For each section there is a long and a short version of its id.  Description of accepted values:  BETA: &#39;parsing&#39; (optional)
     * @param  string $x_request_id Used to correlate requests with their responses within a customer&#39;s application, for logging and error reporting.  Format: Free string, but a valid UUIDv4 is recommended. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function geocodeGetRequest($at = null, $in = null, $limit = 20, $q = null, $qq = null, $lang = null, $show = null, $x_request_id = null)
    {
        if ($limit !== null && $limit > 100) {
            throw new \InvalidArgumentException('invalid value for "$limit" when calling DefaultApi.geocodeGet, must be smaller than or equal to 100.');
        }
        if ($limit !== null && $limit < 1) {
            throw new \InvalidArgumentException('invalid value for "$limit" when calling DefaultApi.geocodeGet, must be bigger than or equal to 1.');
        }


        $resourcePath = '/geocode';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($at !== null) {
            if('form' === 'form' && is_array($at)) {
                foreach($at as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['at'] = $at;
            }
        }
        // query params
        if ($in !== null) {
            if('form' === 'form' && is_array($in)) {
                foreach($in as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['in'] = $in;
            }
        }
        // query params
        if ($limit !== null) {
            if('form' === 'form' && is_array($limit)) {
                foreach($limit as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['limit'] = $limit;
            }
        }
        // query params
        if ($q !== null) {
            if('form' === 'form' && is_array($q)) {
                foreach($q as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['q'] = $q;
            }
        }
        // query params
        if ($qq !== null) {
            if('form' === 'form' && is_array($qq)) {
                foreach($qq as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['qq'] = $qq;
            }
        }
        // query params
        if ($lang !== null) {
            if('form' === 'form' && is_array($lang)) {
                foreach($lang as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['lang'] = $lang;
            }
        }
        // query params
        if (is_array($show)) {
            $show = ObjectSerializer::serializeCollection($show, 'form', true);
        }
        if ($show !== null) {
            $queryParams['show'] = $show;
        }

        // header params
        if ($x_request_id !== null) {
            $headerParams['X-Request-ID'] = ObjectSerializer::toHeaderValue($x_request_id);
        }



        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('apiKey');
        if ($apiKey !== null) {
            $queryParams['apiKey'] = $apiKey;
        }
        // this endpoint requires Bearer (JWT) authentication (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHosts = ["https://geocode.search.hereapi.com/v1"];
        if ($this->hostIndex < 0 || $this->hostIndex >= sizeof($operationHosts)) {
            throw new \InvalidArgumentException("Invalid index {$this->hostIndex} when selecting the host. Must be less than ".sizeof($operationHosts));
        }
        $operationHost = $operationHosts[$this->hostIndex];

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation lookupGet
     *
     * Lookup By ID
     *
     * This oepration contains host(s) defined in the OpenAP spec. Use 'hostIndex' to select the host.
     * URL: https://lookup.search.hereapi.com/v1
     *
     * @param  string $id Location ID, which is the ID of a result item eg. of a Discover request (required)
     * @param  string $lang Select the language to be used for result rendering from a list of [BCP 47](https://en.wikipedia.org/wiki/IETF_language_tag) compliant language codes. (optional)
     * @param  string[] $show Select additional fields to be rendered in the response. Please note that some of the fields involve additional webservice calls and can increase the overall response time.  The value is a comma-separated list of the sections to be enabled. For each section there is a long and a short version of its id.  Description of accepted values:  &#39;phonemes&#39;: Renders phonemes for address and place names into the results. (optional)
     * @param  string $x_request_id Used to correlate requests with their responses within a customer&#39;s application, for logging and error reporting.  Format: Free string, but a valid UUIDv4 is recommended. (optional)
     *
     * @throws \Here\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Here\Model\LookupResponse|\Here\Model\ErrorResponse|\Here\Model\ErrorResponse|\Here\Model\ErrorResponse|\Here\Model\ErrorResponse
     */
    public function lookupGet($id, $lang = null, $show = null, $x_request_id = null)
    {
        list($response) = $this->lookupGetWithHttpInfo($id, $lang, $show, $x_request_id);
        return $response;
    }

    /**
     * Operation lookupGetWithHttpInfo
     *
     * Lookup By ID
     *
     * This oepration contains host(s) defined in the OpenAP spec. Use 'hostIndex' to select the host.
     * URL: https://lookup.search.hereapi.com/v1
     *
     * @param  string $id Location ID, which is the ID of a result item eg. of a Discover request (required)
     * @param  string $lang Select the language to be used for result rendering from a list of [BCP 47](https://en.wikipedia.org/wiki/IETF_language_tag) compliant language codes. (optional)
     * @param  string[] $show Select additional fields to be rendered in the response. Please note that some of the fields involve additional webservice calls and can increase the overall response time.  The value is a comma-separated list of the sections to be enabled. For each section there is a long and a short version of its id.  Description of accepted values:  &#39;phonemes&#39;: Renders phonemes for address and place names into the results. (optional)
     * @param  string $x_request_id Used to correlate requests with their responses within a customer&#39;s application, for logging and error reporting.  Format: Free string, but a valid UUIDv4 is recommended. (optional)
     *
     * @throws \Here\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Here\Model\LookupResponse|\Here\Model\ErrorResponse|\Here\Model\ErrorResponse|\Here\Model\ErrorResponse|\Here\Model\ErrorResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function lookupGetWithHttpInfo($id, $lang = null, $show = null, $x_request_id = null)
    {
        $request = $this->lookupGetRequest($id, $lang, $show, $x_request_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\Here\Model\LookupResponse' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Here\Model\LookupResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    if ('\Here\Model\ErrorResponse' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Here\Model\ErrorResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 404:
                    if ('\Here\Model\ErrorResponse' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Here\Model\ErrorResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 405:
                    if ('\Here\Model\ErrorResponse' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Here\Model\ErrorResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 503:
                    if ('\Here\Model\ErrorResponse' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Here\Model\ErrorResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Here\Model\LookupResponse';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Here\Model\LookupResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Here\Model\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Here\Model\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 405:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Here\Model\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 503:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Here\Model\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation lookupGetAsync
     *
     * Lookup By ID
     *
     * This oepration contains host(s) defined in the OpenAP spec. Use 'hostIndex' to select the host.
     * URL: https://lookup.search.hereapi.com/v1
     *
     * @param  string $id Location ID, which is the ID of a result item eg. of a Discover request (required)
     * @param  string $lang Select the language to be used for result rendering from a list of [BCP 47](https://en.wikipedia.org/wiki/IETF_language_tag) compliant language codes. (optional)
     * @param  string[] $show Select additional fields to be rendered in the response. Please note that some of the fields involve additional webservice calls and can increase the overall response time.  The value is a comma-separated list of the sections to be enabled. For each section there is a long and a short version of its id.  Description of accepted values:  &#39;phonemes&#39;: Renders phonemes for address and place names into the results. (optional)
     * @param  string $x_request_id Used to correlate requests with their responses within a customer&#39;s application, for logging and error reporting.  Format: Free string, but a valid UUIDv4 is recommended. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function lookupGetAsync($id, $lang = null, $show = null, $x_request_id = null)
    {
        return $this->lookupGetAsyncWithHttpInfo($id, $lang, $show, $x_request_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation lookupGetAsyncWithHttpInfo
     *
     * Lookup By ID
     *
     * This oepration contains host(s) defined in the OpenAP spec. Use 'hostIndex' to select the host.
     * URL: https://lookup.search.hereapi.com/v1
     *
     * @param  string $id Location ID, which is the ID of a result item eg. of a Discover request (required)
     * @param  string $lang Select the language to be used for result rendering from a list of [BCP 47](https://en.wikipedia.org/wiki/IETF_language_tag) compliant language codes. (optional)
     * @param  string[] $show Select additional fields to be rendered in the response. Please note that some of the fields involve additional webservice calls and can increase the overall response time.  The value is a comma-separated list of the sections to be enabled. For each section there is a long and a short version of its id.  Description of accepted values:  &#39;phonemes&#39;: Renders phonemes for address and place names into the results. (optional)
     * @param  string $x_request_id Used to correlate requests with their responses within a customer&#39;s application, for logging and error reporting.  Format: Free string, but a valid UUIDv4 is recommended. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function lookupGetAsyncWithHttpInfo($id, $lang = null, $show = null, $x_request_id = null)
    {
        $returnType = '\Here\Model\LookupResponse';
        $request = $this->lookupGetRequest($id, $lang, $show, $x_request_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'lookupGet'
     *
     * This oepration contains host(s) defined in the OpenAP spec. Use 'hostIndex' to select the host.
     * URL: https://lookup.search.hereapi.com/v1
     *
     * @param  string $id Location ID, which is the ID of a result item eg. of a Discover request (required)
     * @param  string $lang Select the language to be used for result rendering from a list of [BCP 47](https://en.wikipedia.org/wiki/IETF_language_tag) compliant language codes. (optional)
     * @param  string[] $show Select additional fields to be rendered in the response. Please note that some of the fields involve additional webservice calls and can increase the overall response time.  The value is a comma-separated list of the sections to be enabled. For each section there is a long and a short version of its id.  Description of accepted values:  &#39;phonemes&#39;: Renders phonemes for address and place names into the results. (optional)
     * @param  string $x_request_id Used to correlate requests with their responses within a customer&#39;s application, for logging and error reporting.  Format: Free string, but a valid UUIDv4 is recommended. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function lookupGetRequest($id, $lang = null, $show = null, $x_request_id = null)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling lookupGet'
            );
        }

        $resourcePath = '/lookup';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($id !== null) {
            if('form' === 'form' && is_array($id)) {
                foreach($id as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['id'] = $id;
            }
        }
        // query params
        if ($lang !== null) {
            if('form' === 'form' && is_array($lang)) {
                foreach($lang as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['lang'] = $lang;
            }
        }
        // query params
        if (is_array($show)) {
            $show = ObjectSerializer::serializeCollection($show, 'form', true);
        }
        if ($show !== null) {
            $queryParams['show'] = $show;
        }

        // header params
        if ($x_request_id !== null) {
            $headerParams['X-Request-ID'] = ObjectSerializer::toHeaderValue($x_request_id);
        }



        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('apiKey');
        if ($apiKey !== null) {
            $queryParams['apiKey'] = $apiKey;
        }
        // this endpoint requires Bearer (JWT) authentication (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHosts = ["https://lookup.search.hereapi.com/v1"];
        if ($this->hostIndex < 0 || $this->hostIndex >= sizeof($operationHosts)) {
            throw new \InvalidArgumentException("Invalid index {$this->hostIndex} when selecting the host. Must be less than ".sizeof($operationHosts));
        }
        $operationHost = $operationHosts[$this->hostIndex];

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation revgeocodeGet
     *
     * Reverse Geocode
     *
     * This oepration contains host(s) defined in the OpenAP spec. Use 'hostIndex' to select the host.
     * URL: https://revgeocode.search.hereapi.com/v1
     *
     * @param  string $at Specify the center of the search context expressed as coordinates.  Format: &#x60;{latitude},{longitude}&#x60;  Type: &#x60;{decimal},{decimal}&#x60;  Example: &#x60;-13.163068,-72.545128&#x60; (Machu Picchu Mountain, Peru) (required)
     * @param  int $limit Maximum number of results to be returned. (optional, default to 1)
     * @param  string $lang Select the language to be used for result rendering from a list of [BCP 47](https://en.wikipedia.org/wiki/IETF_language_tag) compliant language codes. (optional)
     * @param  string[] $show Select additional fields to be rendered in the response. Please note that some of the fields involve additional webservice calls and can increase the overall response time.  The value is a comma-separated list of the sections to be enabled. For each section there is a long and a short version of its id.  Description of accepted values:  BETA: &#39;parsing&#39; (optional)
     * @param  string $x_request_id Used to correlate requests with their responses within a customer&#39;s application, for logging and error reporting.  Format: Free string, but a valid UUIDv4 is recommended. (optional)
     *
     * @throws \Here\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Here\Model\OpenSearchReverseGeocodeResponse|\Here\Model\ErrorResponse|\Here\Model\ErrorResponse|\Here\Model\ErrorResponse
     */
    public function revgeocodeGet($at, $limit = 1, $lang = null, $show = null, $x_request_id = null)
    {
        list($response) = $this->revgeocodeGetWithHttpInfo($at, $limit, $lang, $show, $x_request_id);
        return $response;
    }

    /**
     * Operation revgeocodeGetWithHttpInfo
     *
     * Reverse Geocode
     *
     * This oepration contains host(s) defined in the OpenAP spec. Use 'hostIndex' to select the host.
     * URL: https://revgeocode.search.hereapi.com/v1
     *
     * @param  string $at Specify the center of the search context expressed as coordinates.  Format: &#x60;{latitude},{longitude}&#x60;  Type: &#x60;{decimal},{decimal}&#x60;  Example: &#x60;-13.163068,-72.545128&#x60; (Machu Picchu Mountain, Peru) (required)
     * @param  int $limit Maximum number of results to be returned. (optional, default to 1)
     * @param  string $lang Select the language to be used for result rendering from a list of [BCP 47](https://en.wikipedia.org/wiki/IETF_language_tag) compliant language codes. (optional)
     * @param  string[] $show Select additional fields to be rendered in the response. Please note that some of the fields involve additional webservice calls and can increase the overall response time.  The value is a comma-separated list of the sections to be enabled. For each section there is a long and a short version of its id.  Description of accepted values:  BETA: &#39;parsing&#39; (optional)
     * @param  string $x_request_id Used to correlate requests with their responses within a customer&#39;s application, for logging and error reporting.  Format: Free string, but a valid UUIDv4 is recommended. (optional)
     *
     * @throws \Here\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Here\Model\OpenSearchReverseGeocodeResponse|\Here\Model\ErrorResponse|\Here\Model\ErrorResponse|\Here\Model\ErrorResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function revgeocodeGetWithHttpInfo($at, $limit = 1, $lang = null, $show = null, $x_request_id = null)
    {
        $request = $this->revgeocodeGetRequest($at, $limit, $lang, $show, $x_request_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\Here\Model\OpenSearchReverseGeocodeResponse' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Here\Model\OpenSearchReverseGeocodeResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    if ('\Here\Model\ErrorResponse' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Here\Model\ErrorResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 405:
                    if ('\Here\Model\ErrorResponse' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Here\Model\ErrorResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 503:
                    if ('\Here\Model\ErrorResponse' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Here\Model\ErrorResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Here\Model\OpenSearchReverseGeocodeResponse';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Here\Model\OpenSearchReverseGeocodeResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Here\Model\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 405:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Here\Model\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 503:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Here\Model\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation revgeocodeGetAsync
     *
     * Reverse Geocode
     *
     * This oepration contains host(s) defined in the OpenAP spec. Use 'hostIndex' to select the host.
     * URL: https://revgeocode.search.hereapi.com/v1
     *
     * @param  string $at Specify the center of the search context expressed as coordinates.  Format: &#x60;{latitude},{longitude}&#x60;  Type: &#x60;{decimal},{decimal}&#x60;  Example: &#x60;-13.163068,-72.545128&#x60; (Machu Picchu Mountain, Peru) (required)
     * @param  int $limit Maximum number of results to be returned. (optional, default to 1)
     * @param  string $lang Select the language to be used for result rendering from a list of [BCP 47](https://en.wikipedia.org/wiki/IETF_language_tag) compliant language codes. (optional)
     * @param  string[] $show Select additional fields to be rendered in the response. Please note that some of the fields involve additional webservice calls and can increase the overall response time.  The value is a comma-separated list of the sections to be enabled. For each section there is a long and a short version of its id.  Description of accepted values:  BETA: &#39;parsing&#39; (optional)
     * @param  string $x_request_id Used to correlate requests with their responses within a customer&#39;s application, for logging and error reporting.  Format: Free string, but a valid UUIDv4 is recommended. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function revgeocodeGetAsync($at, $limit = 1, $lang = null, $show = null, $x_request_id = null)
    {
        return $this->revgeocodeGetAsyncWithHttpInfo($at, $limit, $lang, $show, $x_request_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation revgeocodeGetAsyncWithHttpInfo
     *
     * Reverse Geocode
     *
     * This oepration contains host(s) defined in the OpenAP spec. Use 'hostIndex' to select the host.
     * URL: https://revgeocode.search.hereapi.com/v1
     *
     * @param  string $at Specify the center of the search context expressed as coordinates.  Format: &#x60;{latitude},{longitude}&#x60;  Type: &#x60;{decimal},{decimal}&#x60;  Example: &#x60;-13.163068,-72.545128&#x60; (Machu Picchu Mountain, Peru) (required)
     * @param  int $limit Maximum number of results to be returned. (optional, default to 1)
     * @param  string $lang Select the language to be used for result rendering from a list of [BCP 47](https://en.wikipedia.org/wiki/IETF_language_tag) compliant language codes. (optional)
     * @param  string[] $show Select additional fields to be rendered in the response. Please note that some of the fields involve additional webservice calls and can increase the overall response time.  The value is a comma-separated list of the sections to be enabled. For each section there is a long and a short version of its id.  Description of accepted values:  BETA: &#39;parsing&#39; (optional)
     * @param  string $x_request_id Used to correlate requests with their responses within a customer&#39;s application, for logging and error reporting.  Format: Free string, but a valid UUIDv4 is recommended. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function revgeocodeGetAsyncWithHttpInfo($at, $limit = 1, $lang = null, $show = null, $x_request_id = null)
    {
        $returnType = '\Here\Model\OpenSearchReverseGeocodeResponse';
        $request = $this->revgeocodeGetRequest($at, $limit, $lang, $show, $x_request_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'revgeocodeGet'
     *
     * This oepration contains host(s) defined in the OpenAP spec. Use 'hostIndex' to select the host.
     * URL: https://revgeocode.search.hereapi.com/v1
     *
     * @param  string $at Specify the center of the search context expressed as coordinates.  Format: &#x60;{latitude},{longitude}&#x60;  Type: &#x60;{decimal},{decimal}&#x60;  Example: &#x60;-13.163068,-72.545128&#x60; (Machu Picchu Mountain, Peru) (required)
     * @param  int $limit Maximum number of results to be returned. (optional, default to 1)
     * @param  string $lang Select the language to be used for result rendering from a list of [BCP 47](https://en.wikipedia.org/wiki/IETF_language_tag) compliant language codes. (optional)
     * @param  string[] $show Select additional fields to be rendered in the response. Please note that some of the fields involve additional webservice calls and can increase the overall response time.  The value is a comma-separated list of the sections to be enabled. For each section there is a long and a short version of its id.  Description of accepted values:  BETA: &#39;parsing&#39; (optional)
     * @param  string $x_request_id Used to correlate requests with their responses within a customer&#39;s application, for logging and error reporting.  Format: Free string, but a valid UUIDv4 is recommended. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function revgeocodeGetRequest($at, $limit = 1, $lang = null, $show = null, $x_request_id = null)
    {
        // verify the required parameter 'at' is set
        if ($at === null || (is_array($at) && count($at) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $at when calling revgeocodeGet'
            );
        }
        if ($limit !== null && $limit > 100) {
            throw new \InvalidArgumentException('invalid value for "$limit" when calling DefaultApi.revgeocodeGet, must be smaller than or equal to 100.');
        }
        if ($limit !== null && $limit < 1) {
            throw new \InvalidArgumentException('invalid value for "$limit" when calling DefaultApi.revgeocodeGet, must be bigger than or equal to 1.');
        }


        $resourcePath = '/revgeocode';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($at !== null) {
            if('form' === 'form' && is_array($at)) {
                foreach($at as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['at'] = $at;
            }
        }
        // query params
        if ($limit !== null) {
            if('form' === 'form' && is_array($limit)) {
                foreach($limit as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['limit'] = $limit;
            }
        }
        // query params
        if ($lang !== null) {
            if('form' === 'form' && is_array($lang)) {
                foreach($lang as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['lang'] = $lang;
            }
        }
        // query params
        if (is_array($show)) {
            $show = ObjectSerializer::serializeCollection($show, 'form', true);
        }
        if ($show !== null) {
            $queryParams['show'] = $show;
        }

        // header params
        if ($x_request_id !== null) {
            $headerParams['X-Request-ID'] = ObjectSerializer::toHeaderValue($x_request_id);
        }



        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('apiKey');
        if ($apiKey !== null) {
            $queryParams['apiKey'] = $apiKey;
        }
        // this endpoint requires Bearer (JWT) authentication (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHosts = ["https://revgeocode.search.hereapi.com/v1"];
        if ($this->hostIndex < 0 || $this->hostIndex >= sizeof($operationHosts)) {
            throw new \InvalidArgumentException("Invalid index {$this->hostIndex} when selecting the host. Must be less than ".sizeof($operationHosts));
        }
        $operationHost = $operationHosts[$this->hostIndex];

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create http client option
     *
     * @throws \RuntimeException on file opening failure
     * @return array of http client options
     */
    protected function createHttpClientOption()
    {
        $options = [];
        if ($this->config->getDebug()) {
            $options[RequestOptions::DEBUG] = fopen($this->config->getDebugFile(), 'a');
            if (!$options[RequestOptions::DEBUG]) {
                throw new \RuntimeException('Failed to open the debug file: ' . $this->config->getDebugFile());
            }
        }

        return $options;
    }
}
